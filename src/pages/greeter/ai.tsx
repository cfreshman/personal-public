import React from 'react'
import api, { auth } from 'src/lib/api'
import { useF, useM, useR, useS, useTimeout } from 'src/lib/hooks'
import { useCachedScript } from 'src/lib/hooks_ext'
import { A, InfoLoginBlock, InfoSection, Loader } from '../../components/Info'
import { S, defer, dev } from 'src/lib/util'
import { store } from 'src/lib/store'
import { Scroller } from 'src/components/Scroller'
import { prompt_label, prompts } from './quiz'
import { openLogin } from 'src/lib/auth'
import { APP_COOKIE, hangout, meet } from './util'
import { convertLinks } from 'src/lib/render'


const { named_log, list, strings, truthy, QQ, Q, objects, rand, datetime, copy, display_status } = window as any
const log = named_log('greeter ai')

// parse gail hangouts!
const hangout_query = new URLSearchParams(location.hash.slice(1).replaceAll('QAQ', '&').replaceAll('QEQ', '='))
log({hangout_query})

const AiAction = ({ children }) => <i>*{children}*</i>
const AiText = ({ children, user=false }) => <div className='greeter-ai-text' style={S(`
${user ? `
margin-left: 1em;
filter: invert(1);
` : ''}
`)}>{children}</div>

export const AI = ({ handle=undefined }={}) => {

  const [{ user:viewer }] = auth.use()
  useF(viewer, () => {
    const raw_prefill = Object.fromEntries(hangout_query.entries())
    if (raw_prefill.title) {
      log({raw_prefill})

      const users = raw_prefill.users?.split(',') || []
      if (viewer && users?.includes(viewer)) {
        const t = Number(new Date(raw_prefill.date)) + datetime.duration({ h:1 })
        const prefill = {
          ...raw_prefill,
          users, t,
          public: {
            [viewer]: `gail's plan: "${raw_prefill.plan}"`,
          },
          links: raw_prefill.links?.split('QLQ') || []
        }
        log({prefill})
        defer(() => {
          store.set(APP_COOKIE.HANGOUT_PREFILL, prefill)
          handle.set_path([undefined, 'hangout'])
        })
      }
    }
  })

  // const [loading, set_loading] = useS(true)
  // useTimeout(() => set_loading(false), 3_000)

  const [begin, set_begin] = useS(false)
  const [suggestions, set_suggestions] = useS(undefined)
  const [error, set_error] = useS(undefined)
  const [query, set_query] = useS(undefined)

  handle = {
    ...handle,
    began: async () => {
      try {
        let [{profile:viewer_profile}, {list:meet_list=[] as meet[]},{list:hangout_list=[] as hangout[]}] = await Promise.all([
          api.get('/profile'),
          api.get(`/greeter/meets/${viewer}`),
          api.get(`/greeter/hangouts/${viewer}`),
        ])
        meet_list = meet_list.filter(x => x.t)
        hangout_list = hangout_list.filter(x => x.t)
        // alert(`fetched your ${meet_list.length} meets & ${hangout_list.length} hangouts. these will be processed by GREETER-AI to generate new hangout suggestions`)

        const both_list = [
          ...meet_list.map(x => ({ type:'meet', ...x })),
          ...hangout_list.map(x => ({ type:'hangout', ...x })),
        ].sort((a, b) => a.t - b.t).map(x => {
          x.icon_url = x.icon_url || x.icon_href
          x.icon = !!(x.icon || x.icon_url)
          if (x.icon_url && x.icon_url.length > 30) x.icon_url = x.icon
          delete x._id
          delete x.code
          delete x.icon_href
          return x
        })
        const others = (x => {
          x.delete(viewer)
          return [...x]
        })(new Set(both_list.flatMap(x => x.users)))
      
        // const query_parts = [`hi GREETER-AI! "${viewer}" is my username on freshman.dev and that is how you should refer to me. on freshman.dev/greeter, i have logged ${meet_list.length} first-time meets with new friends and ${hangout_list.length} later hangouts. can you help me think of 3 things to do next? here is the info from my previous meets & hangouts:`]
        // const query_parts = [`THIS IS TEXT GENERATED BY AN AI TOOL ON FRESHMAN.DEV/GREETER:\ni (${viewer}) am trying to generate new things to do with ${others.length} specific people i've hung out with before (${others.join(', ')}) based on logs from a social diary website i use, freshman.dev/greeter. for this purpose i will call you GREETER-AI. hi GREETER-AI! i have logged ${meet_list.length} first-time "meets" and ${hangout_list.length} later "hangouts" across the ${others.length} people i mentioned. can you help me think of 3 specific things to do next with individual people? here is the log of my past meets & hangouts:`]
        // both_list.map(entry => {
        //   if (entry.type === 'meet') {
        //     const meet = entry as meet
        //     // query_parts.push([`${meet.users.join(' & ')} met ${datetime.yyyymmdd(meet.t + datetime.duration({ h:1 }))} at ${meet.location || 'unknown location'}`, ...meet.users.filter(user => meet.public[user]).map(user => `${user} noted "${meet.public[user]}"`)].join('. '))
        //     query_parts.push([`meet: ${meet.users.join(' & ')} met ${datetime.yyyymmdd(meet.t + datetime.duration({ h:1 }))} at ${meet.location || 'unknown location'}`, ...meet.users.filter(user => meet.public[user]).map(user => `${user} noted:\n${meet.public[user].split('\n').map(x => `  ${x}`).join('\n')}`)].join('\n'))
        //   } else {
        //     const hangout = entry as hangout
        //     // query_parts.push([`${hangout.users.join(' & ')} hung out ${datetime.yyyymmdd(hangout.t + datetime.duration({ h:1 }))} at ${hangout.location || 'unknown location'}`, ...hangout.users.filter(user => hangout.public[user]).map(user => `${user} noted "${hangout.public[user]}"`)].join('. '))
        //     query_parts.push([`hangout${hangout.title ? ` "${hangout.title}"` : ''}: ${hangout.users.join(' & ')} hung out ${datetime.yyyymmdd(hangout.t + datetime.duration({ h:1 }))} at ${hangout.location || 'unknown location'}`, ...hangout.users.filter(user => hangout.public[user]).map(user => `${user} noted:\n${hangout.public[user].split('\n').map(x => `  ${x}`).join('\n')}`)].join('\n'))
        //   }
        // })
        // query_parts.push(`those are all the past meets & hangouts. please suggest 3 things to do next with individual people (${others.join(', ')}) by name. please don't reuse the same person across multiple suggestions and make sure to mention at least one specific person per suggestion. try make each specific to a previous event i had with them. make the suggestions as interesting as possible. try to suggest people you think i'd have the best time hanging out with right now. try to come up with cute/cool/fun/funny names for the hangouts. give a "suggested date" for each hangout. thank you GREETER-AI. please end your responses with "Sincerely, GREETER-AI"`)
        
//         const query_parts = [`Hi ChatGPT! I use a social diary called /greeter on freshman.dev where I log all my first-time meets and subsequent hangouts with friends. I'd like you to suggest new activities for me to do with my friends based on these logs.

// Here are the specifics:

// I prefer cheap, low-effort, but interesting and unique hangout suggestions.
// Feel free to suggest locations for events, even if users have entered various texts for locations in the past.
// Focus on creating varied suggestions that balance familiar activities with new experiences.
// Each suggestion should mention at least one specific friend and be tailored to our past activities together.
// Act as "GREETER-AI" and sign the entire message with "Sincerely, GREETER-AI."

// Here is a sample of my past meet and hangout logs:`]
//         both_list.map(entry => {
//           if (entry.type === 'meet') {
//             const meet = entry as meet
//             // query_parts.push([`${meet.users.join(' & ')} met ${datetime.yyyymmdd(meet.t + datetime.duration({ h:1 }))} at ${meet.location || 'unknown location'}`, ...meet.users.filter(user => meet.public[user]).map(user => `${user} noted "${meet.public[user]}"`)].join('. '))
//             query_parts.push([`meet: ${meet.users.join(' & ')} met ${datetime.yyyymmdd(meet.t + datetime.duration({ h:1 }))} at ${meet.location || 'unknown location'}`, ...meet.users.filter(user => meet.public[user]).map(user => `${user} noted:\n${meet.public[user].split('\n').map(x => `  ${x}`).join('\n')}`)].join('\n'))
//           } else {
//             const hangout = entry as hangout
//             // query_parts.push([`${hangout.users.join(' & ')} hung out ${datetime.yyyymmdd(hangout.t + datetime.duration({ h:1 }))} at ${hangout.location || 'unknown location'}`, ...hangout.users.filter(user => hangout.public[user]).map(user => `${user} noted "${hangout.public[user]}"`)].join('. '))
//             query_parts.push([`hangout${hangout.title ? ` "${hangout.title}"` : ''}: ${hangout.users.join(' & ')} hung out ${datetime.yyyymmdd(hangout.t + datetime.duration({ h:1 }))} at ${hangout.location || 'unknown location'}`, ...hangout.users.filter(user => hangout.public[user]).map(user => `${user} noted:\n${hangout.public[user].split('\n').map(x => `  ${x}`).join('\n')}`)].join('\n'))
//           }
//         })
//         // query_parts.push(`those are all the past meets & hangouts. please suggest 3 things to do next with individual people (${others.join(', ')}) by name. please don't reuse the same person across multiple suggestions and make sure to mention at least one specific person per suggestion. try make each specific to a previous event i had with them. make the suggestions as interesting as possible. try to suggest people you think i'd have the best time hanging out with right now. try to come up with cute/cool/fun/funny names for the hangouts. give a "suggested date" for each hangout. thank you GREETER-AI. please end your responses with "Sincerely, GREETER-AI"`)
//         query_parts.push(`Please suggest three new activities for me to do next with my friends, making each suggestion specific to an individual friend and drawing from our past experiences. Feel free to tell me that I can ask for more suggestions or suggestions for certain friends, or even things to do alone as well.

// Thank you!`)

        const query_parts = []

        query_parts.push(`meta info: username ${viewer}, friends on freshman.dev include ${viewer_profile.friends.join(', ')}`)

        // both_list.map(entry => {
        //   if (entry.type === 'meet') {
        //     const meet = entry as meet
        //     // query_parts.push([`${meet.users.join(' & ')} met ${datetime.yyyymmdd(meet.t + datetime.duration({ h:1 }))} at ${meet.location || 'unknown location'}`, ...meet.users.filter(user => meet.public[user]).map(user => `${user} noted "${meet.public[user]}"`)].join('. '))
        //     query_parts.push([`meet: ${meet.users.join(' & ')} met ${datetime.yyyymmdd(meet.t + datetime.duration({ h:1 }))} at ${meet.location || 'unknown location'}. ${meet.icon ? 'has' : 'no'} image`, ...meet.users.filter(user => meet.public[user]).map(user => `${user} noted:\n${meet.public[user].split('\n').map(x => `| ${x}`).join('\n')}`), `links: ${meet.links.join(', ')||'none'}`].join('\n'))
        //   } else {
        //     const hangout = entry as hangout
        //     // query_parts.push([`${hangout.users.join(' & ')} hung out ${datetime.yyyymmdd(hangout.t + datetime.duration({ h:1 }))} at ${hangout.location || 'unknown location'}`, ...hangout.users.filter(user => hangout.public[user]).map(user => `${user} noted "${hangout.public[user]}"`)].join('. '))
        //     query_parts.push([`hangout${hangout.title ? ` "${hangout.title}"` : ''}: ${hangout.users.join(' & ')} hung out ${datetime.yyyymmdd(hangout.t + datetime.duration({ h:1 }))} at ${hangout.location || 'unknown location'}. ${hangout.icon ? 'has' : 'no'} image`, ...hangout.users.filter(user => hangout.public[user]).map(user => `${user} noted:\n${hangout.public[user].split('\n').map(x => `| ${x}`).join('\n')}`), `links: ${hangout.links.join(', ')||'none'}`].join('\n'))
        //   }
        // })
        query_parts.push(JSON.stringify(both_list))

        const query = query_parts.join('\n\n')
        set_query(query)

        const response = await api.post(`/greeter/ai/suggestions`, { logs:query })
        log(response)
        set_suggestions(response.query)
        set_error(undefined)
      } catch (e) {
        set_error(e.error || e)
      }
    },
  }
  useF(begin, () => begin && handle.began())
  useF(query, log)
  // useF(begin, suggestions, error, query, () => {
  //   QQ('.greeter-ai-text').at(-1)?.scrollIntoView()
  // })
  defer(() => {
    QQ('.greeter-ai-text').at(-1)?.scrollIntoView({ block:'start' })
    Q('#inner-index')?.scrollIntoView({ block:'end' })
  })

  return <>
    <InfoSection className='column wide' labels={[
      'GREETER-AI',
      { text: 'home', href: '/greeter' },
    ]}>
      <AiText>hello {viewer || <>(<a onClick={() => openLogin()}>sign in</a>)</>}. i am GREETER-AI</AiText>
      {/* <AiText>i am an <a href='https://en.wikipedia.org/wiki/Large_language_model'>LLM</a>. i ingest your past hangouts and suggest new ones using <b>MATH</b></AiText> */}
      {/* <AiText>i am an <A tab href='https://en.wikipedia.org/wiki/Large_language_model'>LLM</A> assistant. your favorite LLM (<A tab href='https://chatgpt.com/'>ChatGPT</A>, etc) will ingest your /greeter logs and suggest new hangouts using <b>MATH</b>{!begin ? <>
        .&nbsp;<a onClick={() => set_begin(true)}>begin →</a>
      </> : null}</AiText> */}
      {/* <AiText>i am an <A tab href='https://en.wikipedia.org/wiki/Large_language_model'>LLM</A> assistant. your favorite LLM (<A tab href='https://chatgpt.com/'>ChatGPT</A>, etc) will ingest your /greeter logs and suggest new hangouts using <b>MATH</b></AiText> */}
      <AiText>i am here to <b><i>improve your life</i></b>, not just keep you repeating the same hangouts every week. but you can always ask the LLM for more low-key hangouts too!</AiText>
      {!begin ? <AiText><a onClick={() => set_begin(true)}>begin →</a></AiText> : null}
      {/* {!begin
      ? <AiText>
        <a onClick={() => set_begin(true)}>begin →</a>
      </AiText>
      : !suggestions
      ? <AiText>
        <AiAction>loading meets & hangouts</AiAction> <Loader />
      </AiText>
      : <>
        <AiText>{`here are my hangout suggestions:\n${suggestions}`}</AiText>
      </>} */}
      {!begin
      ? null
      : !(suggestions || error)
      ? <AiText>
        <AiAction>loading meets & hangouts</AiAction> <Loader />
      </AiText>
      : <>
        {/* <AiText>{`this was the query i generated for you:\n${query}`}</AiText> */}
        {/* {dev ? <AiText user>{query}</AiText> : null} */}
        {/* <AiText>{`here are my suggestions:\n`}{suggestions ? suggestions : <>
          {`\n`}
          {`error: ${error || 'no response'}`}
          {`\n\n`}
          instead, <a onClick={e => {
            copy(query)
            display_status(e.target, 'copied!')
          }}>copy</a> the query and paste into <A tab href={'https://chatgpt.com/'}>ChatGPT</A> (or any LLM) yourself. if it's too long, use this prompt splitter: {convertLinks('https://chatgpt-prompt-splitter.vercel.app')}
        </>}</AiText> */}
        <AiText><i>*generated GREETER-AI LLM query from /greeter logs*</i></AiText>
        {/* <AiText>
          <a onClick={e => {
            copy(suggestions)
            display_status(e.target, 'copied!')
          }}>copy</a> and paste the query into <A tab href={'https://chatgpt.com/?temporary-chat=true'}>ChatGPT</A> (or any LLM). if it's too long, use this prompt splitter: {convertLinks('https://chatgpt-prompt-splitter.vercel.app')} (but if you pay for an LLM it'll usually remove the limit - cyrus himself it trying out the paid version of ChatGPT for a month and he want to say that it is VERY cool)
        </AiText> */}
        {/* <AiText>
          <a onClick={e => {
            copy(suggestions)
            display_status(e.target, 'copied!')
          }}>copy</a> and paste the query into <A tab href={'https://chatgpt.com/?temporary-chat=true'}>ChatGPT</A> (or any LLM)
        </AiText> */}
        {/* <AiText>
          <a onClick={e => {
            copy(suggestions)
            display_status(e.target, 'copied!')
          }}>copy</a> and paste the query into <A tab href={'https://chatgpt.com/?temporary-chat=true'}>ChatGPT</A> (or any LLM). {`tips:
- query too long? use `}{convertLinks('https://chatgpt-prompt-splitter.vercel.app')}{`
- if you pay for an LLM it *should* remove the limit
- (cyrus is trying paid ChatGPT for a month and it is VERY cool)`}
        </AiText> */}
        <AiText>
          <a onClick={e => {
            copy(suggestions)
            display_status(e.target, 'copied!')
          }}>copy</a> and paste the query into <A tab href={'https://chatgpt.com/'}>ChatGPT</A> (or any LLM). {`tips:
- query too long? use `}{convertLinks('https://chatgpt-prompt-splitter.vercel.app')}{`
- if you pay for an LLM it *should* remove the limit
- (cyrus is trying paid ChatGPT for a month and it is VERY cool)`}
        </AiText>
      </>}
    </InfoSection>
  </>
}

// prefilled is too long! - using ChatGPT? here's a prefilled `}<A href={`https://chatgpt.com/?q=${encodeURIComponent(suggestions)}`}>regular</A>{` or `}<A href={`https://chatgpt.com/?temporary-chat=true&q=${encodeURIComponent(suggestions)}`}>temp</A>{` prompt
