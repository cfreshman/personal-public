<!-- cyrusfreshman 2023 -->
<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>cards</title>
<link rel="icon" href="/raw/cards/icon.png">
<link rel="apple-touch-icon-precomposed" href="/raw/cards/icon.png">
<meta property="og:image" content="">
<meta property="og:title" content="">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="">
<style>
  :root {
    --background: #f9f8f6;
    --color: #101010;
  }
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0;
    min-height: 500px;
  }
  html {
    background: var(--background);
    color: var(--color);
    font-size: 15px;
  }
  body {
    font-family: SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    overflow-x: visible;
  }
  a {
    color: inherit;
    text-decoration: underline;
    cursor: pointer;
  }
  #freshman_dev {
    position: fixed;
    top: .5em;
    right: .5em;
    text-decoration: none;
    font-size: .9em;
    padding: .15em .3em;
    border: 1px solid black;
    border-radius: 2px;
    opacity: .3;
    text-transform: uppercase;
  }
  #freshman_dev::after {
    content: " →";
  }
  @keyframes loader {
  100% { transform: rotate(360deg) }
  }
  .loader {
    display: inline-block;
    border: .15em solid #0000;
    border-left-color: currentColor;
    animation: loader 1.5s infinite linear;
  }
  .loader, .loader::after {
    border-radius: 50%;
    width: .8em;
    height: .8em;
  }
</style>
</head>
<body>

  <script type='text/javascript'>
    window.Q = (doc, selector) => {
      if (selector === undefined) {
        selector = doc
        doc = document
      }
      return doc.querySelector(selector)
    }
    window.QQ = (doc, selector) => {
      if (selector === undefined) {
        selector = doc
        doc = document
      }
      return Array.from(doc.querySelectorAll(selector))
    }
    window.on = (el, evts, func, opts=undefined) => evts.split(' ').map(evt => el.addEventListener(evt, func, opts))
    const detectVertical = () => {
      window.vertical = window.innerWidth < window.innerHeight
      document.body.classList[vertical ? 'add' : 'remove']('vertical')
    }
    on(window, 'resize', detectVertical)
    detectVertical()
    
    const node = html => {
      const _temp = document.createElement('div')
      _temp.innerHTML = html
      return _temp.children[0]
    }
  
    const range = n => Array.from({ length: n }).map((_, i) => i)
    const defer = (f=()=>{}, ms=0) => {
      let r, rj
      const p = new Promise((resolve, reject) => [r, rj] = [resolve, reject])
      setTimeout(async _=> r(typeof f === 'function' ? f() : f), ms)
      return Object.assign(p, { interrupt: reject => rj(reject) })
    }
    const add = (a, b) => {
      const returnArray = Array.isArray(a) || Array.isArray(b)
      ;[a, b] = [a, b].map(x => Array.isArray(x) ? x : [x])
      const value = range(Math.max(a.length, b.length)).map(i => (a[i] ?? 0) + (b[i] ?? 0))
      return returnArray ? value : value[0]
    }
    const scale = (a, b) => {
      const returnArray = Array.isArray(a) || Array.isArray(b)
      if (Array.isArray(a) && !Array.isArray(b)) b = range(a.length).map(i => b)
      else if (Array.isArray(b) && !Array.isArray(a)) a = range(b.length).map(i => a)
      else if (!returnArray) {
        ;[a, b] = [[a], [b]] 
      }
      const value = range(Math.max(a.length, b.length)).map(i => (a[i] ?? 0) * (b[i] ?? 0))
      return returnArray ? value : value[0]
    }
  
    // don't use this for anything important
    class Random {
      constructor(seed=Date.now()) {
        this.seed(seed)
      }
      seed(x) {
        this._seed = x
        this.i = 0
      }
      random() {
        this.i += 1
        return ((this._seed / 1_000 + 1_000) / (this.i + 1_000)) * 1_000 % 1
      }
    }
    window.seededRandom = new Random()
  </script>
  <script>
// external - socket.io.min.js
/*!
 * Socket.IO v4.5.0
 * (c) 2014-2022 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).io=e()}(this,(function(){"use strict";function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(e)}function e(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function n(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function r(t,e,r){return e&&n(t.prototype,e),r&&n(t,r),t}function i(){return i=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},i.apply(this,arguments)}function o(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&a(t,e)}function s(t){return s=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},s(t)}function a(t,e){return a=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},a(t,e)}function c(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function u(t,e,n){return u=c()?Reflect.construct:function(t,e,n){var r=[null];r.push.apply(r,e);var i=new(Function.bind.apply(t,r));return n&&a(i,n.prototype),i},u.apply(null,arguments)}function h(t){var e="function"==typeof Map?new Map:void 0;return h=function(t){if(null===t||(n=t,-1===Function.toString.call(n).indexOf("[native code]")))return t;var n;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return u(t,arguments,s(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),a(r,t)},h(t)}function f(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function l(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return f(t)}function p(t){var e=c();return function(){var n,r=s(t);if(e){var i=s(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return l(this,n)}}function d(t,e,n){return d="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=s(t)););return t}(t,e);if(r){var i=Object.getOwnPropertyDescriptor(r,e);return i.get?i.get.call(n):i.value}},d(t,e,n||t)}function y(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function v(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=function(t,e){if(t){if("string"==typeof t)return y(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?y(t,e):void 0}}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0,i=function(){};return{s:i,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,s=!0,a=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return s=t.done,t},e:function(t){a=!0,o=t},f:function(){try{s||null==n.return||n.return()}finally{if(a)throw o}}}}var g=Object.create(null);g.open="0",g.close="1",g.ping="2",g.pong="3",g.message="4",g.upgrade="5",g.noop="6";var m=Object.create(null);Object.keys(g).forEach((function(t){m[g[t]]=t}));for(var k={type:"error",data:"parser error"},b="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===Object.prototype.toString.call(Blob),w="function"==typeof ArrayBuffer,_=function(t,e,n){var r,i=t.type,o=t.data;return b&&o instanceof Blob?e?n(o):A(o,n):w&&(o instanceof ArrayBuffer||(r=o,"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(r):r&&r.buffer instanceof ArrayBuffer))?e?n(o):A(new Blob([o]),n):n(g[i]+(o||""))},A=function(t,e){var n=new FileReader;return n.onload=function(){var t=n.result.split(",")[1];e("b"+t)},n.readAsDataURL(t)},E="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",O="undefined"==typeof Uint8Array?[]:new Uint8Array(256),R=0;R<E.length;R++)O[E.charCodeAt(R)]=R;var T="function"==typeof ArrayBuffer,C=function(t,e){if("string"!=typeof t)return{type:"message",data:S(t,e)};var n=t.charAt(0);return"b"===n?{type:"message",data:B(t.substring(1),e)}:m[n]?t.length>1?{type:m[n],data:t.substring(1)}:{type:m[n]}:k},B=function(t,e){if(T){var n=function(t){var e,n,r,i,o,s=.75*t.length,a=t.length,c=0;"="===t[t.length-1]&&(s--,"="===t[t.length-2]&&s--);var u=new ArrayBuffer(s),h=new Uint8Array(u);for(e=0;e<a;e+=4)n=O[t.charCodeAt(e)],r=O[t.charCodeAt(e+1)],i=O[t.charCodeAt(e+2)],o=O[t.charCodeAt(e+3)],h[c++]=n<<2|r>>4,h[c++]=(15&r)<<4|i>>2,h[c++]=(3&i)<<6|63&o;return u}(t);return S(n,e)}return{base64:!0,data:t}},S=function(t,e){return"blob"===e&&t instanceof ArrayBuffer?new Blob([t]):t},N=String.fromCharCode(30);function x(t){if(t)return function(t){for(var e in x.prototype)t[e]=x.prototype[e];return t}(t)}x.prototype.on=x.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},x.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},x.prototype.off=x.prototype.removeListener=x.prototype.removeAllListeners=x.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,r=this._callbacks["$"+t];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var i=0;i<r.length;i++)if((n=r[i])===e||n.fn===e){r.splice(i,1);break}return 0===r.length&&delete this._callbacks["$"+t],this},x.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),n=this._callbacks["$"+t],r=1;r<arguments.length;r++)e[r-1]=arguments[r];if(n){r=0;for(var i=(n=n.slice(0)).length;r<i;++r)n[r].apply(this,e)}return this},x.prototype.emitReserved=x.prototype.emit,x.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},x.prototype.hasListeners=function(t){return!!this.listeners(t).length};var L="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")();function P(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return n.reduce((function(e,n){return t.hasOwnProperty(n)&&(e[n]=t[n]),e}),{})}var j=setTimeout,q=clearTimeout;function I(t,e){e.useNativeTimers?(t.setTimeoutFn=j.bind(L),t.clearTimeoutFn=q.bind(L)):(t.setTimeoutFn=setTimeout.bind(L),t.clearTimeoutFn=clearTimeout.bind(L))}var D,F=function(t){o(r,t);var n=p(r);function r(t,i,o){var s;return e(this,r),(s=n.call(this,t)).description=i,s.context=o,s.type="TransportError",s}return r}(h(Error)),M=function(t){o(i,t);var n=p(i);function i(t){var r;return e(this,i),(r=n.call(this)).writable=!1,I(f(r),t),r.opts=t,r.query=t.query,r.readyState="",r.socket=t.socket,r}return r(i,[{key:"onError",value:function(t,e,n){return d(s(i.prototype),"emitReserved",this).call(this,"error",new F(t,e,n)),this}},{key:"open",value:function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this}},{key:"close",value:function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this}},{key:"send",value:function(t){"open"===this.readyState&&this.write(t)}},{key:"onOpen",value:function(){this.readyState="open",this.writable=!0,d(s(i.prototype),"emitReserved",this).call(this,"open")}},{key:"onData",value:function(t){var e=C(t,this.socket.binaryType);this.onPacket(e)}},{key:"onPacket",value:function(t){d(s(i.prototype),"emitReserved",this).call(this,"packet",t)}},{key:"onClose",value:function(t){this.readyState="closed",d(s(i.prototype),"emitReserved",this).call(this,"close",t)}}]),i}(x),U="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),V={},H=0,K=0;function Y(t){var e="";do{e=U[t%64]+e,t=Math.floor(t/64)}while(t>0);return e}function z(){var t=Y(+new Date);return t!==D?(H=0,D=t):t+"."+Y(H++)}for(;K<64;K++)V[U[K]]=K;function W(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e}function $(t){for(var e={},n=t.split("&"),r=0,i=n.length;r<i;r++){var o=n[r].split("=");e[decodeURIComponent(o[0])]=decodeURIComponent(o[1])}return e}var J=!1;try{J="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(t){}var X=J;function G(t){var e=t.xdomain;try{if("undefined"!=typeof XMLHttpRequest&&(!e||X))return new XMLHttpRequest}catch(t){}if(!e)try{return new(L[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}function Q(){}var Z=null!=new G({xdomain:!1}).responseType,tt=function(t){o(s,t);var n=p(s);function s(t){var r;if(e(this,s),(r=n.call(this,t)).polling=!1,"undefined"!=typeof location){var i="https:"===location.protocol,o=location.port;o||(o=i?"443":"80"),r.xd="undefined"!=typeof location&&t.hostname!==location.hostname||o!==t.port,r.xs=t.secure!==i}var a=t&&t.forceBase64;return r.supportsBinary=Z&&!a,r}return r(s,[{key:"name",get:function(){return"polling"}},{key:"doOpen",value:function(){this.poll()}},{key:"pause",value:function(t){var e=this;this.readyState="pausing";var n=function(){e.readyState="paused",t()};if(this.polling||!this.writable){var r=0;this.polling&&(r++,this.once("pollComplete",(function(){--r||n()}))),this.writable||(r++,this.once("drain",(function(){--r||n()})))}else n()}},{key:"poll",value:function(){this.polling=!0,this.doPoll(),this.emitReserved("poll")}},{key:"onData",value:function(t){var e=this;(function(t,e){for(var n=t.split(N),r=[],i=0;i<n.length;i++){var o=C(n[i],e);if(r.push(o),"error"===o.type)break}return r})(t,this.socket.binaryType).forEach((function(t){if("opening"===e.readyState&&"open"===t.type&&e.onOpen(),"close"===t.type)return e.onClose({description:"transport closed by the server"}),!1;e.onPacket(t)})),"closed"!==this.readyState&&(this.polling=!1,this.emitReserved("pollComplete"),"open"===this.readyState&&this.poll())}},{key:"doClose",value:function(){var t=this,e=function(){t.write([{type:"close"}])};"open"===this.readyState?e():this.once("open",e)}},{key:"write",value:function(t){var e=this;this.writable=!1,function(t,e){var n=t.length,r=new Array(n),i=0;t.forEach((function(t,o){_(t,!1,(function(t){r[o]=t,++i===n&&e(r.join(N))}))}))}(t,(function(t){e.doWrite(t,(function(){e.writable=!0,e.emitReserved("drain")}))}))}},{key:"uri",value:function(){var t=this.query||{},e=this.opts.secure?"https":"http",n="";!1!==this.opts.timestampRequests&&(t[this.opts.timestampParam]=z()),this.supportsBinary||t.sid||(t.b64=1),this.opts.port&&("https"===e&&443!==Number(this.opts.port)||"http"===e&&80!==Number(this.opts.port))&&(n=":"+this.opts.port);var r=W(t);return e+"://"+(-1!==this.opts.hostname.indexOf(":")?"["+this.opts.hostname+"]":this.opts.hostname)+n+this.opts.path+(r.length?"?"+r:"")}},{key:"request",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i(t,{xd:this.xd,xs:this.xs},this.opts),new et(this.uri(),t)}},{key:"doWrite",value:function(t,e){var n=this,r=this.request({method:"POST",data:t});r.on("success",e),r.on("error",(function(t,e){n.onError("xhr post error",t,e)}))}},{key:"doPoll",value:function(){var t=this,e=this.request();e.on("data",this.onData.bind(this)),e.on("error",(function(e,n){t.onError("xhr poll error",e,n)})),this.pollXhr=e}}]),s}(M),et=function(t){o(i,t);var n=p(i);function i(t,r){var o;return e(this,i),I(f(o=n.call(this)),r),o.opts=r,o.method=r.method||"GET",o.uri=t,o.async=!1!==r.async,o.data=void 0!==r.data?r.data:null,o.create(),o}return r(i,[{key:"create",value:function(){var t=this,e=P(this.opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");e.xdomain=!!this.opts.xd,e.xscheme=!!this.opts.xs;var n=this.xhr=new G(e);try{n.open(this.method,this.uri,this.async);try{if(this.opts.extraHeaders)for(var r in n.setDisableHeaderCheck&&n.setDisableHeaderCheck(!0),this.opts.extraHeaders)this.opts.extraHeaders.hasOwnProperty(r)&&n.setRequestHeader(r,this.opts.extraHeaders[r])}catch(t){}if("POST"===this.method)try{n.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{n.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in n&&(n.withCredentials=this.opts.withCredentials),this.opts.requestTimeout&&(n.timeout=this.opts.requestTimeout),n.onreadystatechange=function(){4===n.readyState&&(200===n.status||1223===n.status?t.onLoad():t.setTimeoutFn((function(){t.onError("number"==typeof n.status?n.status:0)}),0))},n.send(this.data)}catch(e){return void this.setTimeoutFn((function(){t.onError(e)}),0)}"undefined"!=typeof document&&(this.index=i.requestsCount++,i.requests[this.index]=this)}},{key:"onError",value:function(t){this.emitReserved("error",t,this.xhr),this.cleanup(!0)}},{key:"cleanup",value:function(t){if(void 0!==this.xhr&&null!==this.xhr){if(this.xhr.onreadystatechange=Q,t)try{this.xhr.abort()}catch(t){}"undefined"!=typeof document&&delete i.requests[this.index],this.xhr=null}}},{key:"onLoad",value:function(){var t=this.xhr.responseText;null!==t&&(this.emitReserved("data",t),this.emitReserved("success"),this.cleanup())}},{key:"abort",value:function(){this.cleanup()}}]),i}(x);if(et.requestsCount=0,et.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",nt);else if("function"==typeof addEventListener){addEventListener("onpagehide"in L?"pagehide":"unload",nt,!1)}function nt(){for(var t in et.requests)et.requests.hasOwnProperty(t)&&et.requests[t].abort()}var rt="function"==typeof Promise&&"function"==typeof Promise.resolve?function(t){return Promise.resolve().then(t)}:function(t,e){return e(t,0)},it=L.WebSocket||L.MozWebSocket,ot="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),st=function(t){o(i,t);var n=p(i);function i(t){var r;return e(this,i),(r=n.call(this,t)).supportsBinary=!t.forceBase64,r}return r(i,[{key:"name",get:function(){return"websocket"}},{key:"doOpen",value:function(){if(this.check()){var t=this.uri(),e=this.opts.protocols,n=ot?{}:P(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(n.headers=this.opts.extraHeaders);try{this.ws=ot?new it(t,e,n):e?new it(t,e):new it(t)}catch(t){return this.emitReserved("error",t)}this.ws.binaryType=this.socket.binaryType||"arraybuffer",this.addEventListeners()}}},{key:"addEventListeners",value:function(){var t=this;this.ws.onopen=function(){t.opts.autoUnref&&t.ws._socket.unref(),t.onOpen()},this.ws.onclose=function(e){return t.onClose({description:"websocket connection closed",context:e})},this.ws.onmessage=function(e){return t.onData(e.data)},this.ws.onerror=function(e){return t.onError("websocket error",e)}}},{key:"write",value:function(t){var e=this;this.writable=!1;for(var n=function(n){var r=t[n],i=n===t.length-1;_(r,e.supportsBinary,(function(t){try{e.ws.send(t)}catch(t){}i&&rt((function(){e.writable=!0,e.emitReserved("drain")}),e.setTimeoutFn)}))},r=0;r<t.length;r++)n(r)}},{key:"doClose",value:function(){void 0!==this.ws&&(this.ws.close(),this.ws=null)}},{key:"uri",value:function(){var t=this.query||{},e=this.opts.secure?"wss":"ws",n="";this.opts.port&&("wss"===e&&443!==Number(this.opts.port)||"ws"===e&&80!==Number(this.opts.port))&&(n=":"+this.opts.port),this.opts.timestampRequests&&(t[this.opts.timestampParam]=z()),this.supportsBinary||(t.b64=1);var r=W(t);return e+"://"+(-1!==this.opts.hostname.indexOf(":")?"["+this.opts.hostname+"]":this.opts.hostname)+n+this.opts.path+(r.length?"?"+r:"")}},{key:"check",value:function(){return!(!it||"__initialize"in it&&this.name===i.prototype.name)}}]),i}(M),at={websocket:st,polling:tt},ct=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,ut=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];function ht(t){var e=t,n=t.indexOf("["),r=t.indexOf("]");-1!=n&&-1!=r&&(t=t.substring(0,n)+t.substring(n,r).replace(/:/g,";")+t.substring(r,t.length));for(var i,o,s=ct.exec(t||""),a={},c=14;c--;)a[ut[c]]=s[c]||"";return-1!=n&&-1!=r&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a.pathNames=function(t,e){var n=/\/{2,9}/g,r=e.replace(n,"/").split("/");"/"!=e.substr(0,1)&&0!==e.length||r.splice(0,1);"/"==e.substr(e.length-1,1)&&r.splice(r.length-1,1);return r}(0,a.path),a.queryKey=(i=a.query,o={},i.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(function(t,e,n){e&&(o[e]=n)})),o),a}var ft=function(n){o(a,n);var s=p(a);function a(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e(this,a),r=s.call(this),n&&"object"===t(n)&&(o=n,n=null),n?(n=ht(n),o.hostname=n.host,o.secure="https"===n.protocol||"wss"===n.protocol,o.port=n.port,n.query&&(o.query=n.query)):o.host&&(o.hostname=ht(o.host).host),I(f(r),o),r.secure=null!=o.secure?o.secure:"undefined"!=typeof location&&"https:"===location.protocol,o.hostname&&!o.port&&(o.port=r.secure?"443":"80"),r.hostname=o.hostname||("undefined"!=typeof location?location.hostname:"localhost"),r.port=o.port||("undefined"!=typeof location&&location.port?location.port:r.secure?"443":"80"),r.transports=o.transports||["polling","websocket"],r.readyState="",r.writeBuffer=[],r.prevBufferLen=0,r.opts=i({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!0},o),r.opts.path=r.opts.path.replace(/\/$/,"")+"/","string"==typeof r.opts.query&&(r.opts.query=$(r.opts.query)),r.id=null,r.upgrades=null,r.pingInterval=null,r.pingTimeout=null,r.pingTimeoutTimer=null,"function"==typeof addEventListener&&(r.opts.closeOnBeforeunload&&addEventListener("beforeunload",(function(){r.transport&&(r.transport.removeAllListeners(),r.transport.close())}),!1),"localhost"!==r.hostname&&(r.offlineEventListener=function(){r.onClose("transport close",{description:"network connection lost"})},addEventListener("offline",r.offlineEventListener,!1))),r.open(),r}return r(a,[{key:"createTransport",value:function(t){var e=i({},this.opts.query);e.EIO=4,e.transport=t,this.id&&(e.sid=this.id);var n=i({},this.opts.transportOptions[t],this.opts,{query:e,socket:this,hostname:this.hostname,secure:this.secure,port:this.port});return new at[t](n)}},{key:"open",value:function(){var t,e=this;if(this.opts.rememberUpgrade&&a.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket"))t="websocket";else{if(0===this.transports.length)return void this.setTimeoutFn((function(){e.emitReserved("error","No transports available")}),0);t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)}},{key:"setTransport",value:function(t){var e=this;this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",this.onDrain.bind(this)).on("packet",this.onPacket.bind(this)).on("error",this.onError.bind(this)).on("close",(function(t){return e.onClose("transport close",t)}))}},{key:"probe",value:function(t){var e=this,n=this.createTransport(t),r=!1;a.priorWebsocketSuccess=!1;var i=function(){r||(n.send([{type:"ping",data:"probe"}]),n.once("packet",(function(t){if(!r)if("pong"===t.type&&"probe"===t.data){if(e.upgrading=!0,e.emitReserved("upgrading",n),!n)return;a.priorWebsocketSuccess="websocket"===n.name,e.transport.pause((function(){r||"closed"!==e.readyState&&(f(),e.setTransport(n),n.send([{type:"upgrade"}]),e.emitReserved("upgrade",n),n=null,e.upgrading=!1,e.flush())}))}else{var i=new Error("probe error");i.transport=n.name,e.emitReserved("upgradeError",i)}})))};function o(){r||(r=!0,f(),n.close(),n=null)}var s=function(t){var r=new Error("probe error: "+t);r.transport=n.name,o(),e.emitReserved("upgradeError",r)};function c(){s("transport closed")}function u(){s("socket closed")}function h(t){n&&t.name!==n.name&&o()}var f=function(){n.removeListener("open",i),n.removeListener("error",s),n.removeListener("close",c),e.off("close",u),e.off("upgrading",h)};n.once("open",i),n.once("error",s),n.once("close",c),this.once("close",u),this.once("upgrading",h),n.open()}},{key:"onOpen",value:function(){if(this.readyState="open",a.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush(),"open"===this.readyState&&this.opts.upgrade&&this.transport.pause)for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},{key:"onPacket",value:function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emitReserved("packet",t),this.emitReserved("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"ping":this.resetPingTimeout(),this.sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emitReserved("data",t.data),this.emitReserved("message",t.data)}}},{key:"onHandshake",value:function(t){this.emitReserved("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.maxPayload=t.maxPayload,this.onOpen(),"closed"!==this.readyState&&this.resetPingTimeout()}},{key:"resetPingTimeout",value:function(){var t=this;this.clearTimeoutFn(this.pingTimeoutTimer),this.pingTimeoutTimer=this.setTimeoutFn((function(){t.onClose("ping timeout")}),this.pingInterval+this.pingTimeout),this.opts.autoUnref&&this.pingTimeoutTimer.unref()}},{key:"onDrain",value:function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()}},{key:"flush",value:function(){if("closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){var t=this.getWritablePackets();this.transport.send(t),this.prevBufferLen=t.length,this.emitReserved("flush")}}},{key:"getWritablePackets",value:function(){if(!(this.maxPayload&&"polling"===this.transport.name&&this.writeBuffer.length>1))return this.writeBuffer;for(var t,e=1,n=0;n<this.writeBuffer.length;n++){var r=this.writeBuffer[n].data;if(r&&(e+="string"==typeof(t=r)?function(t){for(var e=0,n=0,r=0,i=t.length;r<i;r++)(e=t.charCodeAt(r))<128?n+=1:e<2048?n+=2:e<55296||e>=57344?n+=3:(r++,n+=4);return n}(t):Math.ceil(1.33*(t.byteLength||t.size))),n>0&&e>this.maxPayload)return this.writeBuffer.slice(0,n);e+=2}return this.writeBuffer}},{key:"write",value:function(t,e,n){return this.sendPacket("message",t,e,n),this}},{key:"send",value:function(t,e,n){return this.sendPacket("message",t,e,n),this}},{key:"sendPacket",value:function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){(n=n||{}).compress=!1!==n.compress;var i={type:t,data:e,options:n};this.emitReserved("packetCreate",i),this.writeBuffer.push(i),r&&this.once("flush",r),this.flush()}}},{key:"close",value:function(){var t=this,e=function(){t.onClose("forced close"),t.transport.close()},n=function n(){t.off("upgrade",n),t.off("upgradeError",n),e()},r=function(){t.once("upgrade",n),t.once("upgradeError",n)};return"opening"!==this.readyState&&"open"!==this.readyState||(this.readyState="closing",this.writeBuffer.length?this.once("drain",(function(){t.upgrading?r():e()})):this.upgrading?r():e()),this}},{key:"onError",value:function(t){a.priorWebsocketSuccess=!1,this.emitReserved("error",t),this.onClose("transport error",t)}},{key:"onClose",value:function(t,e){"opening"!==this.readyState&&"open"!==this.readyState&&"closing"!==this.readyState||(this.clearTimeoutFn(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),"function"==typeof removeEventListener&&removeEventListener("offline",this.offlineEventListener,!1),this.readyState="closed",this.id=null,this.emitReserved("close",t,e),this.writeBuffer=[],this.prevBufferLen=0)}},{key:"filterUpgrades",value:function(t){for(var e=[],n=0,r=t.length;n<r;n++)~this.transports.indexOf(t[n])&&e.push(t[n]);return e}}]),a}(x);ft.protocol=4;var lt="function"==typeof ArrayBuffer,pt=Object.prototype.toString,dt="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===pt.call(Blob),yt="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===pt.call(File);function vt(t){return lt&&(t instanceof ArrayBuffer||function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer}(t))||dt&&t instanceof Blob||yt&&t instanceof File}function gt(e,n){if(!e||"object"!==t(e))return!1;if(Array.isArray(e)){for(var r=0,i=e.length;r<i;r++)if(gt(e[r]))return!0;return!1}if(vt(e))return!0;if(e.toJSON&&"function"==typeof e.toJSON&&1===arguments.length)return gt(e.toJSON(),!0);for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)&&gt(e[o]))return!0;return!1}function mt(t){var e=[],n=t.data,r=t;return r.data=kt(n,e),r.attachments=e.length,{packet:r,buffers:e}}function kt(e,n){if(!e)return e;if(vt(e)){var r={_placeholder:!0,num:n.length};return n.push(e),r}if(Array.isArray(e)){for(var i=new Array(e.length),o=0;o<e.length;o++)i[o]=kt(e[o],n);return i}if("object"===t(e)&&!(e instanceof Date)){var s={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&(s[a]=kt(e[a],n));return s}return e}function bt(t,e){return t.data=wt(t.data,e),t.attachments=void 0,t}function wt(e,n){if(!e)return e;if(e&&e._placeholder)return n[e.num];if(Array.isArray(e))for(var r=0;r<e.length;r++)e[r]=wt(e[r],n);else if("object"===t(e))for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(e[i]=wt(e[i],n));return e}var _t;!function(t){t[t.CONNECT=0]="CONNECT",t[t.DISCONNECT=1]="DISCONNECT",t[t.EVENT=2]="EVENT",t[t.ACK=3]="ACK",t[t.CONNECT_ERROR=4]="CONNECT_ERROR",t[t.BINARY_EVENT=5]="BINARY_EVENT",t[t.BINARY_ACK=6]="BINARY_ACK"}(_t||(_t={}));var At=function(){function t(n){e(this,t),this.replacer=n}return r(t,[{key:"encode",value:function(t){return t.type!==_t.EVENT&&t.type!==_t.ACK||!gt(t)?[this.encodeAsString(t)]:(t.type=t.type===_t.EVENT?_t.BINARY_EVENT:_t.BINARY_ACK,this.encodeAsBinary(t))}},{key:"encodeAsString",value:function(t){var e=""+t.type;return t.type!==_t.BINARY_EVENT&&t.type!==_t.BINARY_ACK||(e+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(e+=t.nsp+","),null!=t.id&&(e+=t.id),null!=t.data&&(e+=JSON.stringify(t.data,this.replacer)),e}},{key:"encodeAsBinary",value:function(t){var e=mt(t),n=this.encodeAsString(e.packet),r=e.buffers;return r.unshift(n),r}}]),t}(),Et=function(n){o(a,n);var i=p(a);function a(t){var n;return e(this,a),(n=i.call(this)).reviver=t,n}return r(a,[{key:"add",value:function(t){var e;if("string"==typeof t)(e=this.decodeString(t)).type===_t.BINARY_EVENT||e.type===_t.BINARY_ACK?(this.reconstructor=new Ot(e),0===e.attachments&&d(s(a.prototype),"emitReserved",this).call(this,"decoded",e)):d(s(a.prototype),"emitReserved",this).call(this,"decoded",e);else{if(!vt(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");(e=this.reconstructor.takeBinaryData(t))&&(this.reconstructor=null,d(s(a.prototype),"emitReserved",this).call(this,"decoded",e))}}},{key:"decodeString",value:function(t){var e=0,n={type:Number(t.charAt(0))};if(void 0===_t[n.type])throw new Error("unknown packet type "+n.type);if(n.type===_t.BINARY_EVENT||n.type===_t.BINARY_ACK){for(var r=e+1;"-"!==t.charAt(++e)&&e!=t.length;);var i=t.substring(r,e);if(i!=Number(i)||"-"!==t.charAt(e))throw new Error("Illegal attachments");n.attachments=Number(i)}if("/"===t.charAt(e+1)){for(var o=e+1;++e;){if(","===t.charAt(e))break;if(e===t.length)break}n.nsp=t.substring(o,e)}else n.nsp="/";var s=t.charAt(e+1);if(""!==s&&Number(s)==s){for(var c=e+1;++e;){var u=t.charAt(e);if(null==u||Number(u)!=u){--e;break}if(e===t.length)break}n.id=Number(t.substring(c,e+1))}if(t.charAt(++e)){var h=this.tryParse(t.substr(e));if(!a.isPayloadValid(n.type,h))throw new Error("invalid payload");n.data=h}return n}},{key:"tryParse",value:function(t){try{return JSON.parse(t,this.reviver)}catch(t){return!1}}},{key:"destroy",value:function(){this.reconstructor&&this.reconstructor.finishedReconstruction()}}],[{key:"isPayloadValid",value:function(e,n){switch(e){case _t.CONNECT:return"object"===t(n);case _t.DISCONNECT:return void 0===n;case _t.CONNECT_ERROR:return"string"==typeof n||"object"===t(n);case _t.EVENT:case _t.BINARY_EVENT:return Array.isArray(n)&&n.length>0;case _t.ACK:case _t.BINARY_ACK:return Array.isArray(n)}}}]),a}(x),Ot=function(){function t(n){e(this,t),this.packet=n,this.buffers=[],this.reconPack=n}return r(t,[{key:"takeBinaryData",value:function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=bt(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null}},{key:"finishedReconstruction",value:function(){this.reconPack=null,this.buffers=[]}}]),t}(),Rt=Object.freeze({__proto__:null,protocol:5,get PacketType(){return _t},Encoder:At,Decoder:Et});function Tt(t,e,n){return t.on(e,n),function(){t.off(e,n)}}var Ct=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1}),Bt=function(t){o(i,t);var n=p(i);function i(t,r,o){var s;return e(this,i),(s=n.call(this)).connected=!1,s.receiveBuffer=[],s.sendBuffer=[],s.ids=0,s.acks={},s.flags={},s.io=t,s.nsp=r,o&&o.auth&&(s.auth=o.auth),s.io._autoConnect&&s.open(),s}return r(i,[{key:"disconnected",get:function(){return!this.connected}},{key:"subEvents",value:function(){if(!this.subs){var t=this.io;this.subs=[Tt(t,"open",this.onopen.bind(this)),Tt(t,"packet",this.onpacket.bind(this)),Tt(t,"error",this.onerror.bind(this)),Tt(t,"close",this.onclose.bind(this))]}}},{key:"active",get:function(){return!!this.subs}},{key:"connect",value:function(){return this.connected||(this.subEvents(),this.io._reconnecting||this.io.open(),"open"===this.io._readyState&&this.onopen()),this}},{key:"open",value:function(){return this.connect()}},{key:"send",value:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return e.unshift("message"),this.emit.apply(this,e),this}},{key:"emit",value:function(t){if(Ct.hasOwnProperty(t))throw new Error('"'+t+'" is a reserved event name');for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];n.unshift(t);var i={type:_t.EVENT,data:n,options:{}};if(i.options.compress=!1!==this.flags.compress,"function"==typeof n[n.length-1]){var o=this.ids++,s=n.pop();this._registerAckCallback(o,s),i.id=o}var a=this.io.engine&&this.io.engine.transport&&this.io.engine.transport.writable,c=this.flags.volatile&&(!a||!this.connected);return c||(this.connected?(this.notifyOutgoingListeners(i),this.packet(i)):this.sendBuffer.push(i)),this.flags={},this}},{key:"_registerAckCallback",value:function(t,e){var n=this,r=this.flags.timeout;if(void 0!==r){var i=this.io.setTimeoutFn((function(){delete n.acks[t];for(var r=0;r<n.sendBuffer.length;r++)n.sendBuffer[r].id===t&&n.sendBuffer.splice(r,1);e.call(n,new Error("operation has timed out"))}),r);this.acks[t]=function(){n.io.clearTimeoutFn(i);for(var t=arguments.length,r=new Array(t),o=0;o<t;o++)r[o]=arguments[o];e.apply(n,[null].concat(r))}}else this.acks[t]=e}},{key:"packet",value:function(t){t.nsp=this.nsp,this.io._packet(t)}},{key:"onopen",value:function(){var t=this;"function"==typeof this.auth?this.auth((function(e){t.packet({type:_t.CONNECT,data:e})})):this.packet({type:_t.CONNECT,data:this.auth})}},{key:"onerror",value:function(t){this.connected||this.emitReserved("connect_error",t)}},{key:"onclose",value:function(t,e){this.connected=!1,delete this.id,this.emitReserved("disconnect",t,e)}},{key:"onpacket",value:function(t){if(t.nsp===this.nsp)switch(t.type){case _t.CONNECT:if(t.data&&t.data.sid){var e=t.data.sid;this.onconnect(e)}else this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case _t.EVENT:case _t.BINARY_EVENT:this.onevent(t);break;case _t.ACK:case _t.BINARY_ACK:this.onack(t);break;case _t.DISCONNECT:this.ondisconnect();break;case _t.CONNECT_ERROR:this.destroy();var n=new Error(t.data.message);n.data=t.data.data,this.emitReserved("connect_error",n)}}},{key:"onevent",value:function(t){var e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?this.emitEvent(e):this.receiveBuffer.push(Object.freeze(e))}},{key:"emitEvent",value:function(t){if(this._anyListeners&&this._anyListeners.length){var e,n=v(this._anyListeners.slice());try{for(n.s();!(e=n.n()).done;){e.value.apply(this,t)}}catch(t){n.e(t)}finally{n.f()}}d(s(i.prototype),"emit",this).apply(this,t)}},{key:"ack",value:function(t){var e=this,n=!1;return function(){if(!n){n=!0;for(var r=arguments.length,i=new Array(r),o=0;o<r;o++)i[o]=arguments[o];e.packet({type:_t.ACK,id:t,data:i})}}}},{key:"onack",value:function(t){var e=this.acks[t.id];"function"==typeof e&&(e.apply(this,t.data),delete this.acks[t.id])}},{key:"onconnect",value:function(t){this.id=t,this.connected=!0,this.emitBuffered(),this.emitReserved("connect")}},{key:"emitBuffered",value:function(){var t=this;this.receiveBuffer.forEach((function(e){return t.emitEvent(e)})),this.receiveBuffer=[],this.sendBuffer.forEach((function(e){t.notifyOutgoingListeners(e),t.packet(e)})),this.sendBuffer=[]}},{key:"ondisconnect",value:function(){this.destroy(),this.onclose("io server disconnect")}},{key:"destroy",value:function(){this.subs&&(this.subs.forEach((function(t){return t()})),this.subs=void 0),this.io._destroy(this)}},{key:"disconnect",value:function(){return this.connected&&this.packet({type:_t.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}},{key:"close",value:function(){return this.disconnect()}},{key:"compress",value:function(t){return this.flags.compress=t,this}},{key:"volatile",get:function(){return this.flags.volatile=!0,this}},{key:"timeout",value:function(t){return this.flags.timeout=t,this}},{key:"onAny",value:function(t){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(t),this}},{key:"prependAny",value:function(t){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(t),this}},{key:"offAny",value:function(t){if(!this._anyListeners)return this;if(t){for(var e=this._anyListeners,n=0;n<e.length;n++)if(t===e[n])return e.splice(n,1),this}else this._anyListeners=[];return this}},{key:"listenersAny",value:function(){return this._anyListeners||[]}},{key:"onAnyOutgoing",value:function(t){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(t),this}},{key:"prependAnyOutgoing",value:function(t){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(t),this}},{key:"offAnyOutgoing",value:function(t){if(!this._anyOutgoingListeners)return this;if(t){for(var e=this._anyOutgoingListeners,n=0;n<e.length;n++)if(t===e[n])return e.splice(n,1),this}else this._anyOutgoingListeners=[];return this}},{key:"listenersAnyOutgoing",value:function(){return this._anyOutgoingListeners||[]}},{key:"notifyOutgoingListeners",value:function(t){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){var e,n=v(this._anyOutgoingListeners.slice());try{for(n.s();!(e=n.n()).done;){e.value.apply(this,t.data)}}catch(t){n.e(t)}finally{n.f()}}}}]),i}(x);function St(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}St.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},St.prototype.reset=function(){this.attempts=0},St.prototype.setMin=function(t){this.ms=t},St.prototype.setMax=function(t){this.max=t},St.prototype.setJitter=function(t){this.jitter=t};var Nt=function(n){o(s,n);var i=p(s);function s(n,r){var o,a;e(this,s),(o=i.call(this)).nsps={},o.subs=[],n&&"object"===t(n)&&(r=n,n=void 0),(r=r||{}).path=r.path||"/socket.io",o.opts=r,I(f(o),r),o.reconnection(!1!==r.reconnection),o.reconnectionAttempts(r.reconnectionAttempts||1/0),o.reconnectionDelay(r.reconnectionDelay||1e3),o.reconnectionDelayMax(r.reconnectionDelayMax||5e3),o.randomizationFactor(null!==(a=r.randomizationFactor)&&void 0!==a?a:.5),o.backoff=new St({min:o.reconnectionDelay(),max:o.reconnectionDelayMax(),jitter:o.randomizationFactor()}),o.timeout(null==r.timeout?2e4:r.timeout),o._readyState="closed",o.uri=n;var c=r.parser||Rt;return o.encoder=new c.Encoder,o.decoder=new c.Decoder,o._autoConnect=!1!==r.autoConnect,o._autoConnect&&o.open(),o}return r(s,[{key:"reconnection",value:function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection}},{key:"reconnectionAttempts",value:function(t){return void 0===t?this._reconnectionAttempts:(this._reconnectionAttempts=t,this)}},{key:"reconnectionDelay",value:function(t){var e;return void 0===t?this._reconnectionDelay:(this._reconnectionDelay=t,null===(e=this.backoff)||void 0===e||e.setMin(t),this)}},{key:"randomizationFactor",value:function(t){var e;return void 0===t?this._randomizationFactor:(this._randomizationFactor=t,null===(e=this.backoff)||void 0===e||e.setJitter(t),this)}},{key:"reconnectionDelayMax",value:function(t){var e;return void 0===t?this._reconnectionDelayMax:(this._reconnectionDelayMax=t,null===(e=this.backoff)||void 0===e||e.setMax(t),this)}},{key:"timeout",value:function(t){return arguments.length?(this._timeout=t,this):this._timeout}},{key:"maybeReconnectOnOpen",value:function(){!this._reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()}},{key:"open",value:function(t){var e=this;if(~this._readyState.indexOf("open"))return this;this.engine=new ft(this.uri,this.opts);var n=this.engine,r=this;this._readyState="opening",this.skipReconnect=!1;var i=Tt(n,"open",(function(){r.onopen(),t&&t()})),o=Tt(n,"error",(function(n){r.cleanup(),r._readyState="closed",e.emitReserved("error",n),t?t(n):r.maybeReconnectOnOpen()}));if(!1!==this._timeout){var s=this._timeout;0===s&&i();var a=this.setTimeoutFn((function(){i(),n.close(),n.emit("error",new Error("timeout"))}),s);this.opts.autoUnref&&a.unref(),this.subs.push((function(){clearTimeout(a)}))}return this.subs.push(i),this.subs.push(o),this}},{key:"connect",value:function(t){return this.open(t)}},{key:"onopen",value:function(){this.cleanup(),this._readyState="open",this.emitReserved("open");var t=this.engine;this.subs.push(Tt(t,"ping",this.onping.bind(this)),Tt(t,"data",this.ondata.bind(this)),Tt(t,"error",this.onerror.bind(this)),Tt(t,"close",this.onclose.bind(this)),Tt(this.decoder,"decoded",this.ondecoded.bind(this)))}},{key:"onping",value:function(){this.emitReserved("ping")}},{key:"ondata",value:function(t){this.decoder.add(t)}},{key:"ondecoded",value:function(t){this.emitReserved("packet",t)}},{key:"onerror",value:function(t){this.emitReserved("error",t)}},{key:"socket",value:function(t,e){var n=this.nsps[t];return n||(n=new Bt(this,t,e),this.nsps[t]=n),n}},{key:"_destroy",value:function(t){for(var e=0,n=Object.keys(this.nsps);e<n.length;e++){var r=n[e];if(this.nsps[r].active)return}this._close()}},{key:"_packet",value:function(t){for(var e=this.encoder.encode(t),n=0;n<e.length;n++)this.engine.write(e[n],t.options)}},{key:"cleanup",value:function(){this.subs.forEach((function(t){return t()})),this.subs.length=0,this.decoder.destroy()}},{key:"_close",value:function(){this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close"),this.engine&&this.engine.close()}},{key:"disconnect",value:function(){return this._close()}},{key:"onclose",value:function(t,e){this.cleanup(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",t,e),this._reconnection&&!this.skipReconnect&&this.reconnect()}},{key:"reconnect",value:function(){var t=this;if(this._reconnecting||this.skipReconnect)return this;var e=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{var n=this.backoff.duration();this._reconnecting=!0;var r=this.setTimeoutFn((function(){e.skipReconnect||(t.emitReserved("reconnect_attempt",e.backoff.attempts),e.skipReconnect||e.open((function(n){n?(e._reconnecting=!1,e.reconnect(),t.emitReserved("reconnect_error",n)):e.onreconnect()})))}),n);this.opts.autoUnref&&r.unref(),this.subs.push((function(){clearTimeout(r)}))}}},{key:"onreconnect",value:function(){var t=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",t)}}]),s}(x),xt={};function Lt(e,n){"object"===t(e)&&(n=e,e=void 0);var r,i=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=t;n=n||"undefined"!=typeof location&&location,null==t&&(t=n.protocol+"//"+n.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?n.protocol+t:n.host+t),/^(https?|wss?):\/\//.test(t)||(t=void 0!==n?n.protocol+"//"+t:"https://"+t),r=ht(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";var i=-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+i+":"+r.port+e,r.href=r.protocol+"://"+i+(n&&n.port===r.port?"":":"+r.port),r}(e,(n=n||{}).path||"/socket.io"),o=i.source,s=i.id,a=i.path,c=xt[s]&&a in xt[s].nsps;return n.forceNew||n["force new connection"]||!1===n.multiplex||c?r=new Nt(o,n):(xt[s]||(xt[s]=new Nt(o,n)),r=xt[s]),i.query&&!n.query&&(n.query=i.queryKey),r.socket(i.path,n)}return i(Lt,{Manager:Nt,Socket:Bt,io:Lt,connect:Lt}),Lt}));
  </script>
  <script type="text/javascript">
    let socket
    if (this.io) {
      const backend = location.host.replace(':3000', ':5050')
      console.debug('[socket CONNECT]', backend)
      window.socket = socket = io(backend, {
        closeOnBeforeunload: false,
      })
      socket?.on('connect', () => console.debug('[socket CONNECTED]'))
    }
  </script>
  
  <div id="objects">
    <div id="cards"></div>
  </div>
  <div id="ui">
    <div id="bottom"></div>
  </div>
  <script>
    if (location.hash) {
      location.href = location.href.replace('#', '?')
    }
    const path_room_match = /cards\/(.+)/.exec(location.pathname.replace(/\/.+\.html/, ''))
    let room_id = (location.search || '').replace(/^\?/, '') || (path_room_match && path_room_match[1]) || '', prev
    if (room_id.includes('prev/')) {
      prev = room_id.split('prev/')[1]
      room_id = ''
    }
    const room_events_id = room_id ? `cards-${room_id}` : 'cards'

    // const path_prefix = location.pathname.replace(path_room_match, '')
    // const other_href = location.origin + path_prefix + (location.search ? '?' : '/') + (prev || 'prev/'+room_id)
    // if (room_id || prev) Q('#ui').append(node(`
    //   <div id="top-right">
    //     <button onclick="location.href = other_href">${room_id || 'default'}</button>
    //   </div>`))
    
    // listen for 'cards' socket events
    socket?.on('echo:'+room_events_id, (...x) => console.debug('[socket] echo', x))
    socket?.emit('echo', room_events_id)

    const colors = ['red', 'black']
    const suits = ['hearts', 'diamonds', 'spades', 'clubs']
    const symbols = ['♥', '♦', '♠', '♣']
    const suitToColor = suit => colors[suits.indexOf(suit) % colors.length]
    const suitToSymbol = suit => symbols[suits.indexOf(suit) % symbols.length]
    const ranks = [...range(9).map(i => i + 2), 'J', 'Q', 'K', 'A']
    const n_cards = suits.length * ranks.length
    const generateCardId = (suit, rank) => `${suit[0]}${rank}`

    let position_offset = [0, 0]
    const getTransformedBoundingClientRect = element => {
      const rect = element.getBoundingClientRect()
      rect.x -= position_offset[0]
      rect.y -= position_offset[1]
      return rect
    }

    // card elements
    const cards = {}
    let order = undefined
    const flipped = {}
    const spots = {} // { x, y, suit? }
    const stacks = {} // { id: string, bottom: [x, y], next?: { id, next } } | { bottom: [x, y], next? }
    const id_to_stack = {}
    const card_ratio = [2.45, 3.5]
    let card_size, deck_offset
    const stack_offset_ratio = [0, .5]
    const deck_offset_ratio = .4
    const computeSnapDistance = card_size => card_size[0] * .5
    const computeCardExtents = () => {
      let min_x, min_y, max_x, max_y
      Object.values(cards).map(card => {
        const rect = getTransformedBoundingClientRect(card.element)
        min_x = min_x !== undefined ? Math.min(min_x, rect.x) : rect.x
        min_y = min_y !== undefined ? Math.min(min_y, rect.y) : rect.y
        max_x = max_x !== undefined ? Math.max(max_x, rect.x + rect.width) : rect.x + rect.width
        max_y = max_y !== undefined ? Math.max(max_y, rect.y + rect.height) : rect.y + rect.height
      })
      return {
        min: { x: min_x, y: min_y },
        max: { x: max_x, y: max_y },
      }
    }
    const centerCardView = (card_extents=computeCardExtents()) => {
      if (vertical) {
        const button_extents = getTransformedBoundingClientRect(Q('#bottom'))
        const card_shift = [
          document.body.clientWidth/2 - (card_extents.max.x - card_extents.min.x)/2 - card_extents.min.x,
          (document.body.clientHeight - button_extents.height)/2 - (card_extents.max.y - card_extents.min.y)/2 - card_extents.min.y,
        ]
        updatePositionOffset(card_shift)
      }
    }
    let z = 0

    // cursor elements
    const CURSOR_RANGE = 1e16
    const cursor_id = Math.round(Math.random() * CURSOR_RANGE)
    const cursors = {} // { timestamp, text, element }
    const non_text_cursor_timeout = 5 * 60_000 // remove static non-text cursors after ~5 minutes
    setInterval(() => {
      Object.entries(cursors).map(([id, cursor]) => {
        if (!cursor.text && Date.now() - cursor.timestamp > non_text_cursor_timeout) {
          cursor.element.remove()
          delete cursors[id]
        }
      })
    }, non_text_cursor_timeout) 

    let wait_for_init = Date.now() // unset after 'state' request or 'init' response
    const Action = {
      splay: (stack_or_id, as_deck=undefined) => {
        const stack = typeof(stack_or_id) === 'string' ? stacks[stack_or_id] || id_to_stack[stack_or_id] : stack_or_id
        if (!stack) return
        // display as deck or stack
        const root_id = stack.id || stack.next.id
        const root = cards[root_id].element

        // set bottom, and if deck, shift upper cards to right
        const display_as_deck = as_deck ?? (stack.offset?.toString() === '0,0')
        const display_with_handle = display_as_deck && stack.id
        const rect = getTransformedBoundingClientRect(root)
        let [x, y] = [rect.x, rect.y], bottom, last, offset = stack.offset || [0, 0], n = 0
        for (let c = stack; c; c = c.next) n += 1
        let card_offset = deck_offset / Math.min(6, n)
        let edge_width = 0
        console.debug('splay', { display_as_deck, stack, pos: [x, y], deck_offset, card_offset })
        for (let curr = stack, i = 0; curr; curr = curr.next, i += 1) {
          if (!curr.id) continue
          const node_element = cards[curr.id].element
          console.debug('splay', x, y, node_element)
          node_element.style.left = x+'px'
          node_element.style.top = y+'px'
          if (flipped[curr.id]) node_element.classList.add('flipped')
          else node_element.classList.remove('flipped')
          node_element.style.zIndex = z
          bottom = [x, y]

          x += offset[0]
          y += offset[1]
          z += 1
          if (display_with_handle && curr.next) {
            node_element.classList.add('bottom')
            
            card_offset = Math.min(deck_offset - edge_width, card_offset)
            x += card_offset
            edge_width += card_offset
            // if (curr.id === root_id) x += deck_offset
            // if (curr.id === root_id) x += deck_offset - edge_width
            // else x += card_offset
          } else {
            node_element.classList.remove('bottom')
          }
          last = curr
        }
        for (let c = stack; c; c = c.next) c.bottom = bottom
        
        if (!last || last.id === root_id) {
          delete stack.offset
          console.debug('unstacked', stack)
        }
      },
      place: (id, pos=undefined) => {
        console.debug('place', id, pos)
        const element = cards[id].element
        const rect = getTransformedBoundingClientRect(element)
        let [x, y] = pos ? pos : [rect.x, rect.y]
        const stack_offset = stack_offset_ratio.map((x, x_i) => x * card_size[x_i])
        const snap_distance = computeSnapDistance(card_size)

        // replace from current stack
        // (this only loops when card is replaced from stack)
        let stack_node = stacks[id]
        if (stack_node) {
          console.debug('place stack', stack_node, pos)
          delete stack_node.spot
        } else {
          Object.values(stacks).find(stack => {
            let current = stack
            while (current.next) {
              if (current.next.id === id) {
                delete id_to_stack[id]
                stack_node = current.next
                stack_node.offset = stack.offset
                delete current.next
                Action.splay(stack.id || Object.keys(stacks).find(x => x === stack))
                return true
              }
              current = current.next
            }
          })
        }
        if (!stack_node) stack_node = { id, bottom: [rect.x, rect.y] }

        // find stack in new position, if any
        let to_stack = id_to_stack[id] || Object.values(stacks).filter(x => x.id !== id).find(stack => {
          const [s_x, s_y] = stack.bottom
          if (stack.offset && stack.id) {
            const is_deck = stack.offset.toString() === '0,0'
            const base = is_deck && getTransformedBoundingClientRect(cards[stack.id || stack.next.id].element)
            return (
              Math.sqrt(
              Math.pow(x - (s_x + stack.offset[0]), 2)
              + Math.pow(y - (s_y + stack.offset[1]), 2)
              ) < snap_distance
            ) || (
              base && Math.sqrt(
              Math.pow(x - base.x, 2)
              + Math.pow(y - base.y, 2)
              ) < snap_distance
            )
          } else {
            const same_flip = true // flipped[stack.id || stack.next?.id] === flipped[id]
            const empty_spot = !(stack.id || stack.next)
            const below = !empty_spot && Math.sqrt(
              Math.pow(x - (s_x + stack_offset[0]), 2)
              + Math.pow(y - (s_y + stack_offset[1]), 2)
              ) < snap_distance
            const stacked = Math.sqrt(
              Math.pow(x - s_x, 2)
              + Math.pow(y - s_y, 2)
              ) < snap_distance
            const match = same_flip && (stacked || below)
            if (match) console.debug('stack match', { match, below, stack }, stack.bottom, stack.offset)
            if (match && !empty_spot && !stack.offset) {
              stack.offset = below ? stack_offset : [0, 0]
              console.debug('offset', match, below, [s_x, s_y], Math.sqrt(
              Math.pow(x - (s_x + stack_offset[0]), 2)
              + Math.pow(y - (s_y + stack_offset[1]), 2)
              ), stack.offset.toString())
            }
            return match
          }
        })
        if (to_stack) {
          // add to stack
          delete stacks[id]
          let current = to_stack, in_stack = false
          while (current.next) {
            console.debug(current.id, id)
            // if (current.id === id) return // short-circuit, keep card in stack
            // if (current.id === id) in_stack = true
            current = current.next
          }
          current.next = stack_node
          if (to_stack.offset) {
            x = to_stack.bottom[0] + to_stack.offset[0]
            y = to_stack.bottom[1] + to_stack.offset[1]
          } else {
            x = to_stack.bottom[0]
            y = to_stack.bottom[1]
          }
          id_to_stack[id] = to_stack
        } else {
          to_stack = stack_node
        }

        // snap to spot
        Object.values(spots).filter(x => !x.suit || x.suit === cards[id].suit).some(spot => {
          const stacked = Math.sqrt(
            Math.pow(x - spot.x, 2)
            + Math.pow(y - spot.y, 2)
            ) < snap_distance
          if (stacked) {
            x = spot.x
            y = spot.y
            return true
          }
        })

        console.debug('stack', [x, y], to_stack.offset, to_stack, stack_node)
        stacks[to_stack.id] = to_stack

        // place card & stacked
        element.style.left = x+'px'
        element.style.top = y+'px'
        Action.splay(id)
      },
      flip: (id, is_flipped=undefined) => {
        console.debug('flip', id, cards[id], is_flipped)
        let stack = stacks[id] || id_to_stack[id] || cards[id]
        
        // if flipped and (not bottom card, or stacked on spot), flip all & reverse order
        let bottom = stack
        for (; bottom.next; bottom = bottom.next) {}
        if ((bottom.id !== id || !stack.id) && stack.offset?.toString() === '0,0') {
          const rect = getTransformedBoundingClientRect(cards[stack.id || stack.next.id].element)
          console.debug('flip deck', id, stack)
          let ids = []
          for (let c = stack; c; c = c.next) {
            ids.push(c.id)
            flipped[c.id] = is_flipped ?? !flipped[c.id]
          }
          if (stack.id) {
            delete stacks[stack.id]
            id_to_stack[stack.id] = stack
          }
          for (let c = stack; c; c = c.next) c.id = ids.pop()
          if (stack.id) {
            stacks[stack.id] = stack
            delete id_to_stack[stack.id]
            Action.place(stack.id, [rect.x, rect.y])
          } else {
            Action.splay(stack)
          }
        } else {
          // flip face up from card
          // flip face down from stack
          let c = stack
          // if (!is_flipped) 
          for (; c.next && c.id !== id; c = c.next) {}
          for (; c; c = c.next) {
            // ids.push(c.id)
            flipped[c.id] = is_flipped ?? !flipped[c.id]
            // console.debug(c.id, flipped[c.id])
          }
          Action.splay(stack)
          // Action.place(stack.id || stack.next.id) // update stack ordering
        }
        console.debug({ flipped })
      },
      spot: ([x, y], suit=undefined) => {
        const id = [x, y].map(x => Math.round(x * 10)/10).join()
        const spot = spots[id] = {
          x, y, suit,
          element: node(`
          <div id=${id} class="card-container" style="
          position: fixed;
          top: ${y}px;
          left: ${x}px;
          ">
            <div class="card spot" style="
            width: ${card_ratio[0]}em;
            height: ${card_ratio[1]}em;
            ">
              ${suit ? `
              <div class="card-suit" style="
              font-size: ${
                2.25
              }em;
              ">${
                suitToSymbol(suit)
              }</div>` : ''}
            </div>
          </div>
          `),
        }
        // stacks[id] = { bottom: [x, y] }
        Q('#cards').append(spot.element)
        console.debug('place spot', spot, stacks[id], stacks)
      },
      state: () => {
        wait_for_init = false
        // emit entire board state to new instance
        const action_list = []
        Object.values(stacks).map(stack => {
          for (let current = stack; current; current = current.next) {
            if (current.id) {
              const element = cards[current.id].element
              const rect = getTransformedBoundingClientRect(element)
              if (!current.id) action_list.push(['spot', [rect.x, rect.y]])
              action_list.push(['place', current.id, [rect.x, rect.y]])
              flipped[current.id] && action_list.push(['flip', current.id, flipped[current.id]])
            }
          }
        })
        Object.values(spots).map(({ x, y, suit }) => {
          action_list.push(['spot', [x, y], suit])
        })
        console.debug(action_list)
        socket?.emit('emit', room_events_id, 'init', action_list)
      },
      init: (action_list) => {
        // console.debug(action_list)
        if (wait_for_init) {
          if (!initialized) {
            initialized = action_list
          } else {
            console.debug('init', action_list)
            Action.blank()
            wait_for_init = false
            action_list.map(([action, ...args]) => {
              console.debug(action)
              Action[action](...args)
            })
          }
        }
      },
      cursor: (id, pos=undefined, press=false, text=undefined, temporary=false) => {
        let cursor = cursors[id]
        let [x, y] = pos || []
        const color = `hsl(${id/CURSOR_RANGE * 360} 100% 85%)`
        if (!cursor) {
          cursor = cursors[id] = {
            timestamp: undefined, text: '',
            element: node(`
            <div class="cursor-container" style="
            position: absolute;
            top: ${x}; left: ${y}; width: .5em; height: .5em;
            z-index: 100100100100;
            pointer-events: none;
            user-select: none;
            ">
              <div class="cursor" style="
              position: relative;
              ">
                <div class="cursor-icon" style="
                width: 1em; height: 1em;
                ${id === cursor_id ? 'visibility: hidden;' : ''}
                "></div>
                <div class="cursor-text" style="
                width: max-content; overflow-wrap: nowrap;
                background: ${color};
                border: .1em solid black;
                border-radius: 1em;
                padding: 0 .4em;
                position: absolute;
                top: .82em; left: .75em;
                "></div>
              </div>
            </div>
            `),
          }
          Q('#objects').append(cursor.element)
        }
        cursor.timestamp = Date.now()
        if (pos) {
          cursor.element.style.top = y+'px'
          cursor.element.style.left = x+'px'
        }
        Q(cursor.element, '.cursor-icon').style.background = press
        ? `url("data:image/svg+xml,%3Csvg width='100%' height='100%' viewBox='-.1 -.1 1.2 1.2' fill='${color}' stroke='black' stroke-width='.1' stroke-linejoin='round' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='.5' cy='.5' r='.5' /%3E%3C/svg%3E")`
        : `url("data:image/svg+xml,%3Csvg width='100%' height='100%' viewBox='-.1 -.1 1.2 1.2' fill='${color}' stroke='black' stroke-width='.1' stroke-linejoin='round' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='0 0 1 .25 .25 1 0 0' /%3E%3C/svg%3E")`
        const cursor_text_element = Q(cursor.element, '.cursor-text')
        if (text !== undefined) {
          if (!temporary) cursor.text = text
          cursor_text_element.textContent = text
          cursor_text_element.style.color = temporary ? '#0008' : ''
          cursor.element.style.scale = cursor_text_element.style.scale = ''
        }
        cursor_text_element.style.display = cursor_text_element.textContent ? '' : 'none'
        const rect = getTransformedBoundingClientRect(cursor_text_element)
        if (rect.x + rect.width > document.body.clientWidth) {
          cursor.element.style.scale = cursor_text_element.style.scale = '-1 1'
        } else if (rect.x < 0) {
          cursor.element.style.scale = cursor_text_element.style.scale = ''
        }
      },
      uncursor: id => {
        cursors[id].element?.remove()
        delete cursors[id]
      },
      reset: (_order) => {
        order = _order || suits.flatMap(suit => ranks.map(rank => generateCardId(suit, rank)))

        // remove spots
        Object.keys(spots).map(k => {
          spots[k].element.remove()
          delete spots[k]
          // const stack = stacks[k]
          // if (stack.next) {
          //   stack.id = stack.next.id
          //   stack.offset = stack.next.offset
          //   stack.next = stack.next.next
          //   stacks[stack.id] = stack
          //   delete id_to_stack[stack.id]
          //   // for (let c = stack; c; c = c.next) {
          //   //   id_to_stack[c.id] = stack
          //   // }
          // }
          // delete stacks[k]
        })
        // move elements out of view & flip face-up
        Object.values(cards).forEach(({ id, element }, i) => {
          Action.place(id, [document.body.clientWidth * 10, i * card_size[1]])
          Action.flip(id, false)
        })
        // arrange in grid
        order.forEach((id, i) => {
          const group = Math.floor(i / (order.length / 4))
          const group_i = i % (order.length / 4)
          console.debug(id, group, group_i)
          const c_pos = [
            1 + (card_ratio[0] + .33) * (group_i % (ranks.length/2)),
            .25 
            + (card_ratio[1] + .5) * (group * 2 + Math.floor(group_i / (ranks.length/2)))
            // + (Math.floor(group_i / (ranks.length/2)) === 0 && !_order ? .75 : .5),
            + .5,
          ]
          Action.place(id, c_pos.map((x, x_i) => x / card_ratio[x_i] * card_size[x_i]))
        })
      },
      blank: () => {
        Action.reset()
        Object.values(cards).forEach(({ id, element }, i) => {
          Action.flip(id, false)
          Action.place(id, [document.body.clientWidth * 10, i * card_size[1]])
        })
      },
      deck: (_order=undefined, pos=undefined, reset=true) => {
        const [x, y] = pos || [card_size[0] * .25, card_size[0] * .25]
        order = _order
        if (reset) Action.reset(order)
        order.map(id => {
          Action.flip(id, true)
          Action.place(id, [-card_size[0], 0])
        })
        Action.place(order[0], [x, y])
      },

      interrupt: () => interrupt(),
      center: () => centerCardView(),
    }
    const sync = {}
    const action_keyToId = k => ({
      'spot': 't',
      'state': 'e',
      'interrupt': 'n',
      'center': 'C',
    }[k] || k[0])
    const recursiveFormat = x => {
      if (typeof(x) === 'number') return Math.round(x)
      if (typeof(x) === 'boolean') return x ? 1 : 0
      if (Array.isArray(x)) return x.map(recursiveFormat)
      return x
    }
    Object.entries(Action).map(([k, v]) => {
      const k_id = action_keyToId(k)
      if (sync[k_id]) throw 'REPEATED ACTION LETTER ' + k

      Action[k_id] = Action[k]
      sync[k] = sync[k_id] = (...args) => {
        args = args.map(recursiveFormat)
        socket?.emit('emit', room_events_id, k_id, ...args)
        Action[k](...args)
      }
    })
    console.debug('listen for', 'emit:'+room_events_id, socket)
    socket?.on('emit:'+room_events_id, (action, ...args) => {
      console.debug('[socket]', action, args)
      Action[action] && Action[action](...args)
    })
    socket?.emit('emit', room_events_id) // join room
    on(window, 'beforeunload', e => {
      sync.uncursor(cursor_id)
      socket.close()
    })

    let cursor_edit = ''
    let cursor_down = false
    // let position_offset = [0, document.body.clientWidth < document.body.clientHeight ? document.body.clientHeight / 3 : 0]
    const eventToPosition = e => {
      return add([e.clientX, e.clientY], scale(-1, position_offset))
    }
    const updatePositionOffset = (_position_offset=position_offset) => {
      position_offset = _position_offset
      Q('#objects').style.translate = `${_position_offset[0]}px ${_position_offset[1]}px`
    }
    let pos, down_cursor_pos, down_position_offset
    on(window, 'pointerdown', e => {
      down_position_offset = position_offset
      down_cursor_pos = [e.clientX, e.clientY]
      pos = eventToPosition(e)
      cursor_down = true
      sync.cursor(cursor_id, pos, cursor_down)
    })
    on(window, 'pointerup', e => {
      cursor_down = false
      sync.cursor(cursor_id, undefined, cursor_down)
    })
    on(window, 'pointermove', e => {
      pos = eventToPosition(e)
      sync.cursor(cursor_id, pos, cursor_down)
      if (!down_card) {
        let node = e.target
        while (node && !node.classList.contains('card')) node = node.parentElement
        if (!node && cursor_down) {
          const cursor_pos = [e.clientX, e.clientY]
          updatePositionOffset(add(down_position_offset, add(cursor_pos, scale(-1, down_cursor_pos))))
        }
      }
    })
    on(window, 'keydown', e => {
      if (e.key === 'Enter') {
        sync.cursor(cursor_id, undefined, cursor_down, cursor_edit)
        cursor_edit = ''
      } else if (!e.metaKey) {
        if (e.key === 'Backspace') cursor_edit = e.shiftKey ? '' : cursor_edit.slice(0, -1)
        else if (e.key.length === 1) cursor_edit += e.key
        Action.cursor(cursor_id, undefined, cursor_down, cursor_edit || cursors[cursor_id].text, cursor_edit)
      }
    })

    // request state from other clients & render cards
    let down_card, initialized = false
    socket?.emit('emit', room_events_id, 'state')
    Q('#cards').innerHTML = suits.map(suit => ranks.map(rank => {
      const id = generateCardId(suit, rank)
      defer(_=> {
        const element = Q('#'+id)
        const card = cards[id] = {
          id, suit, rank, element
        }

        if (!card_size) {
          const rect = getTransformedBoundingClientRect(element)
          card_size = [rect.width, rect.height]
          deck_offset = card_size[0] * deck_offset_ratio
          console.debug('INIT', {
            card_size, deck_offset
          })
        } else if (suit === suits.slice(-1)[0] && rank === ranks.slice(-1)[0]) {
          centerCardView()
          if (initialized) Action.init(initialized)
          else initialized = true
        }

        let down, stack, pos, start
        on(element, 'pointerdown', e => {
          const rect = getTransformedBoundingClientRect(element)
          pos = [rect.x, rect.y]
          down = eventToPosition(e)
          start = Date.now()
          cursor_down = true
          sync.cursor(cursor_id, undefined, cursor_down)

          // prepare move: entire stack if part of deck
          stack = stacks[id] || id_to_stack[id]
          let bottom = stack
          for (; bottom.next; bottom = bottom.next) {}
          if (stack.offset?.toString() === '0,0' && id !== bottom.id) {
            down_card = stack.id || stack.next.id
          } else {
            down_card = id
          }
        })
        on(element, 'touchstart', e => e.preventDefault())
        on(window, 'pointermove', e => {
          if (down) {
            e.preventDefault()
            let [x, y] = eventToPosition(e).map((x, i) => pos[i] + (x - down[i]))
            sync.place(down_card, [x, y])
            sync.cursor(cursor_id, undefined, cursor_down)
          }
        })
        on(window, 'pointerup', e => {
          down_card = cursor_down = down = false
          sync.cursor(cursor_id, undefined, cursor_down)
          if (Date.now() - start < 150) sync.flip(id)
        })

        const rect = getTransformedBoundingClientRect(element)
        Action.place(id, [rect.x, rect.y])
      })
      return `
      <div id=${id} class="card-container" style="
      position: fixed;
      top: ${1 + (3.5 + 1) * suits.indexOf(suit)}em;
      left: ${1 + (2.45 + 1) * ranks.indexOf(rank)}em;

      top: ${1 + (3.5 + .25) * ranks.indexOf(rank)}em;
      left: ${1 + (2.45 + 1) * suits.indexOf(suit)}em;

      top: ${.25 
        + (3.5 + .5) * (suits.indexOf(suit) * 2 + Math.floor(ranks.indexOf(rank) / (ranks.length/2)))
        + (Math.floor(ranks.indexOf(rank) / (ranks.length/2)) === 0 ? .75 : .5)}em;
      left: ${1 + (2.45 + .33) * (ranks.indexOf(rank) % (ranks.length/2))}em;
      ">
        <div class="card" style="
        width: ${card_ratio[0]}em;
        height: ${card_ratio[1]}em;
        border: 2px solid ${suitToColor(suit)};
        color: ${suitToColor(suit)};
        ">

          <span class="card-rank">${rank}</span>
          <div class="card-suit" style="
          font-size: ${
            // typeof(rank) === 'string' || rank === 1 ? 2 : rank < 3 ? 1 : .5
            2.25
          }em;
          ">${
            // suitToSymbol(suit).repeat(typeof(rank) === 'number' ? rank : 1)
            suitToSymbol(suit)
          }</div>

        </div>
      </div>
      `
    }).join('\n')).join('\n')

    const _shuffle = async (pos=undefined, reset=true) => {
      // shuffle & stack as face-down deck
      // if already a deck, arrange face-up instead
      const as_deck = Object.values(stacks).length > 1
      const random = new Random()
      order = Object.keys(cards).sort(() => random.random() - .5)
      // await sync.deck(order, pos, reset)
      await (as_deck ? sync.deck(order, pos, reset) : sync.reset(order))
      // if (!as_deck) {
      //   // const padding = range(2).map(x => card_size[0] * .25)
      //   // const spacing = [.55, 1.05].map((x, i) => x * card_size[i])

      //   // const deck = Object.values(stacks)[0]
      //   // const deck_order = []
      //   // for (let c = deck; c; c = c.next) deck_order.unshift(c.id)
      //   // sync.place(deck.id, [-card_size[0], 0])
      //   // for (let i = 0; i < deck_order.length; i++) {
      //   //   const id = deck_order[i]
      //   //   sync.place(id, [i * spacing[0], (i % 2) * spacing[1]])
      //   //   sync.flip(id, false)
      //   // }

      //   // centerCardView()
      //   sync.reset(order)
      // }
    }

    let interrupt = () => {}
    const interrupted = ms => {
      return new Promise(async resolve => {
        interrupt = () => resolve(true)
        defer(() => resolve(false), ms)
      })
    }

    const buttons = {
      shuffle: () => _shuffle(), 
      solitaire: async e => {
        const dealMs = 67
        sync.blank()
        const padding = range(2).map(x => card_size[0] * .25)
        const spacing = [1 + deck_offset_ratio * 1.1, 2].map((x, i) => x * card_size[i])

        // place spots
        // stacks
        for (let i = 0; i < 7; i += 1) {
          sync.spot([padding[0] + spacing[0] * i, padding[1] + spacing[1]])
        }
        // header
        {
          const y = padding[1]
          for (let i = 0; i < 2; i += 1) {
            sync.spot([padding[0] + spacing[0] * 1.5 * i, y])
          }
          for (let i = 0; i < 4; i += 1) {
            // sync.spot([padding[0] + spacing[0] * (i + 3), y], suits[i])
            sync.spot([padding[0] + spacing[0] * (i + 3), y])
          }
        }
        centerCardView({
          min: { x: padding[0], y: padding[1] },
          max: { 
            x: padding[0] + spacing[0] * (3 + 3) + card_size[0],
            y: padding[1] + spacing[1] + 6 * (card_size[1] * stack_offset_ratio[1]) + card_size[1],
          },
        })
        
        // await sync.shuffle(padding, reset=false)
        await _shuffle(padding, reset=false)
        if (await interrupted(100)) return

        // move cards from bottom of deck to stacks
        console.debug(JSON.stringify(stacks))
        const deck = Object.values(stacks)[0]
        const deck_order = []
        for (let c = deck; c; c = c.next) deck_order.push(c.id)
        const flips = []
        const deck_rect = getTransformedBoundingClientRect(cards[deck_order[0]].element)

        const last_pile_card_id = []
        for (let i = 0; i < 7; i += 1) {
          const y = padding[1] + spacing[1] + i * (card_size[1] * stack_offset_ratio[1])
          for (let j = i; j < 7; j += 1) {
            const x = padding[0] + spacing[0] * j
            const id = deck_order.shift()
            sync.place(deck_order[0], [deck_rect.x, deck_rect.y - card_size[1]])
            sync.flip(id, true)
            sync.place(id, last_pile_card_id[j] 
              ? (() => {
                const prev_card = cards[last_pile_card_id[j]]
                const pos = getTransformedBoundingClientRect(prev_card.element)
                return [pos.x, pos.y + (card_size[1] * stack_offset_ratio[1])]
              })() 
              : [x, y])
            last_pile_card_id[j] = id
            // await defer(100)
            // if (j == i) flips.push(id)
            if (j == i) {
              sync.flip(id, false)
              // await defer(50)
            }
            sync.place(deck_order[0], [deck_rect.x, deck_rect.y])
            if (await interrupted(100)) return
          }
        }

        // TODO better fix: clicking last card in pile flips first card in tableau
        {
          for (let i = deck_order.length - 1; i >= 0; i--) {
            sync.place(deck_order[i], [-card_size[0], 0])
          }
          for (let i = 0; i < deck_order.length; i++) {
            sync.place(deck_order[i], [deck_rect.x, deck_rect.y])
          }
        }

        // flip first card in face-up pile
        console.debug('flip face-up', deck_order[deck_order.length - 1])
        const face_up_id = deck_order.pop()
        const face_up_rect = [padding[0] + spacing[0] * 1.5 * 1, padding[1]]
        sync.place(face_up_id, face_up_rect)
        sync.flip(face_up_id, false)
        
        // for (const id of flips) {
        //   sync.flip(id, false)
        //   await defer(50)
        // }
      },
      reset: e => sync.reset(),
      new: e => open('?'+(n => Math.floor(Math.random() * Math.pow(16, n)).toString(16).padStart(n, '0'))(4), '_self'),
    }
    const button_order = Object.keys(buttons)
    if (room_id) {
      buttons[room_id] = e => open('?'+prompt('room id:', room_id).slice(0, 16), '_self')
      button_order.push(room_id) // something weird with ordering
    }
    button_order.forEach(k => {
      const func = buttons[k]
      buttons[k] = async (...args) => {
        sync.interrupt()
        const value = await func(...args)
        centerCardView()
        return value
      }
    })

    Q('#bottom').innerHTML =
      button_order
      .map(k => {
        const name = k.replace(/_/g, ' ')
        const func = buttons[k]
        defer(_=> on(Q(`#button-${k}`), 'click', func))
        return `<button id="button-${k}">${name}</button>`
      })
      .join('\n')
    
    // on(window, 'pointerdown touchstart', e => {
    //   e.stopPropagation()
    //   e.preventDefault()
    // })

  </script>
  <style>
    html, body {
      height: 100%; width: 100%; margin: 0; overflow: hidden;
      font-size: 15px;
    }
    * {
      user-select: none;
      -webkit-user-select: none;
    }
    #cards {
      overflow: visible;
    }
    #ui {
      pointer-events: none;
      margin: .5em;
      position: absolute;
      top: 0; left: 0;
      height: calc(100% - 1em); width: calc(100% - 1em);
      z-index: 100100100100;
      pointer-events: none;
    }
    #ui button {
      pointer-events: all;
      cursor: pointer;
    }
    #bottom {
      position: absolute;
      bottom: 0; left: 0;
    }
    #top-right {
      position: absolute;
      top: 0; right: 0;
    }
    .card {
      border-radius: .15em;
      background: white;
      position: relative;
      cursor: pointer;
    }
    .flipped .card {
      background: #000;
    }
    :is(.flipped, .bottom) .card {
      border-color: #333 !important;
    }
    :is(.flipped, .bottom) .card * {
      display: none;
    }
    .card.spot {
      /* background: #0008; */
      background: #0002;
      cursor: default;
    }
    .card-rank {
      padding: 0 .1em;
      font-size: 1.2em;
      font-family: system-ui;
      font-weight: bold;
    }
    .card-suit {
      position: absolute;
      top: 40%; left: 0%;
      height: 60%; width: 100%;
      display: flex;
      align-items: flex-start; justify-content: center;
      flex-wrap: wrap;
      word-break: break-all;
      line-height: .8;
    }
    .card.spot .card-suit {
      color: #fffc;
    }

    .vertical #bottom {
      display: flex;
      column-gap: .5em;
      width: 100%;
      justify-content: center;
    }
  </style>

</body>
</html>
