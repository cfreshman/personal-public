<!DOCTYPE html>
<html>

<head>
  <title>matchbox.html (tv)</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="icon" href="/raw/matchbox/app/icon.png" />
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    :root {
      font-size: 16px;
      font-family: monospace;
      * {
        box-sizing: border-box;
        font-family: inherit;
      }
    }

    body {
      overflow: hidden;
      background: #111;
    }
    
    #matchbox-canvas {
      /* width: 100% !important;
      height: 100% !important; */
      /* filter: brightness(1.2) contrast(.8) saturate(1); */
    }

    #matchbox-qr {
      width: 50vmin;
      height: 50vmin;
      padding: 1em;
      background: #fff;
      border: 1px solid #000;
      img {
        width: 100%;
        height: 100%;
      }
    }

    button, select {
      appearance: none;
      height: 1.5em;
      border-radius: .75em;
      border: 1px solid #000;
      box-shadow: 0 2px #000;
      translate: 0 -2px;
      background: #eee;
      color: #000;
      padding: 0 .5em;
      text-align: center;
      cursor: pointer;
      &:active {
        box-shadow: none;
        translate: none;
      }
    }

    .gui {
      z-index: 1;
      color: #fff;
      text-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000;
      padding: .5em;
      visibility: hidden;
    }
  </style>
</head>

<body>

  <div id="matchbox-container" class="cover center">
    <canvas id="matchbox-canvas"></canvas>
  </div>
  <div id="gui-menu" class="gui cover center column spaced">
    <div class="center-column gap" style="
    background: #111;
    padding: .5em;
    border: 1px solid #fff;
    border-radius: .5em;
    /* box-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000; */
    ">
      <div>car-racing couch game</div>
      <div style="font-size: 2em"><b>matchbox.html</b></div>
      <!-- <div style="font-size: 2em">scan to play</div> -->
      <div id="matchbox-qr"></div>
      <div style="font-size: 2em"><span id="matchbox-joined">0</span> joined ðŸš—</div>
    </div>
    <div class="row gap">
      <select id="matchbox-select-mode" style="font-size: 2em; display: none" onchange="
      mode = this.value
      "></select>
      <button onclick="start_game()" style="font-size: 2em">start</button>
    </div>
  </div>
  <div id="gui-play" class="gui cover">
    <div class="column">
      <div id="matchbox-scores" class="column gap"></div>
      <div style="font-size: 2em" id="timer">0s</div>
    </div>
    <div class="cover center">
      <div id="matchbox-countdown" style="font-size:5em"></div>
    </div>
  </div>
  <div id="gui-end" class="gui cover center column spaced">
    <!-- <div style="font-size: 2em">final score: <span id="final-score">0</span>ðŸŸ¡</div> -->
    <div id="matchbox-final-scores" class="row spaced" style="align-items:flex-end"></div>
    <div class="row spaced">
      <button style="font-size: 2em" onclick="
      state = STATES.PLAY
      reset_game()
      start_game()
      ">again</button>
      <button style="font-size: 2em" onclick="
      back_to_menu()
      ">menu</button>
    </div>
  </div>

  <script src="/lib/2/common/script.js"></script>
  <script src="/lib/noise.js"></script>
  <script src="/lib/three.js"></script>
  <script src="/lib/2/external/qrcode.min.js"></script>
  <script src="./app/cannon.js"></script>
  <script src="./app/cannon-runner.js"></script>
  <script src="./app/Detector.js"></script>
  <script src="/raw/tv-phone/circuit/script.js"></script>
  <script src="/lib/socket.io.min.js"></script>
  <script type="text/javascript">
    let socket
    if (this.io) {
      const backend = location.host.replace(':3000', ':5050')
      console.debug('[socket CONNECT]', backend)
      window.socket = socket = io(backend, {
        closeOnBeforeunload: false,
      })
      socket?.on('connect', () => console.debug('[socket CONNECTED]'))
    }
  </script>
  <script>
    const log = named_log('matchbox')
    const T = THREE
    const id = store.load('matchbox-id', () => rand.alphanum(12))
    location.hash = id
    const players = []

    const COLORS_CAR = rand.shuffle([
      // 0x000000,
      '#ff0000',
      '#ffff00',
      '#00ff00',
      '#00ffff',
      '#0000ff',
      '#ff00ff',
      // 0xffffff,
      // 0x285ff4,
      // 0x65c467,
      // 0xf8ce46,
      // 0xec4d3e,
    ])
    const COLOR_SAND = 0xffc277 // 0x113355 // 
    const COLOR_LIQUID = 0x44bbff // 0x2277ff // 0xff8888 // 

    const FIELD = 280
    const size = 64
    const tile = FIELD / size
    const chunk_size = 2.5
    const min_height = 1
    const max_height = 45
    const liquid_height = 8
    let rand_off
    const randomize_generate = () => rand_off = rand.i(1_000_000_000)
    function get_height(x, y) {
      zoom = size / chunk_size
      huge = noise.simplex2(x / zoom / 4 - 10000 + rand_off, y / zoom / 4 - 10000 + rand_off)
      large = noise.simplex2(x / zoom * 2 + 10000 + rand_off, y / zoom * 2 + 10000 + rand_off)
      medium = noise.simplex2(x / zoom * 4 + 20000 + rand_off, y / zoom * 4 + 20000 + rand_off)
      small = noise.simplex2(x / zoom * 10 + 30000 + rand_off, y / zoom * 10 + 30000 + rand_off)
      // value = Math.pow(huge*0.3 + large*0.5 + medium*0.15 + small*0.05, 3)
      let height
      value = Math.pow(huge * 0.3 + large * 0.5 + medium * 0.15 + small * 0.0, 3)
      const mid_height = liquid_height + (max_height - liquid_height) / 32
      if (value > 0) {
        height = maths.lerp(mid_height, max_height, Math.sqrt(value))
      } else {
        // height = maths.lerp(mid_height, liquid_height, Math.sqrt(-value))
        height = maths.lerp(mid_height, mid_height, Math.sqrt(-value))
      }

      const dist = V.ne(x, y).ma()
      const outer_dist = V.ne(1, 1).sc(get_border_random(x, y)).sc(size / 6).ma()
      if (dist > outer_dist) {
        height = maths.lerp(height, 0, Math.pow((dist - outer_dist) / outer_dist * 1.5, 2))
      }

      return height
    }
    function get_border_random(x, y) {
      const angle = Math.atan2(y, x)
      return (noise.simplex2(angle / 32 + 10_000_000, 0) + noise.simplex2(angle / 8 + 20_000_000, 0) + noise.simplex2(angle * 2 + 30_000_000, 0)) / 10 + 1
    }

    const runner = new CANNON.Runner({
      normals: true
    })
    const MAX_COINS = 5
    const COIN_DIAMETER = 3, COIN_WIDTH = 1
    const WHEEL_RADIUS = .75
    const MAX_BOOST_PARTICLES = 20
    let boost_particles = []
    let player_vehicles, player_wheels, coins
    let timer = 0

    const STATES = {
      MENU: 'menu',
      PLAY: 'play',
      END: 'end',
    }
    let state = STATES.MENU
    const MODES = {
      REGULAR: 'regular',
      SURVIVAL: 'survival',
    }
    let mode = MODES.REGULAR
    let data = {
      // regular
      // timer,

      // survival
      // timer,
      // stage,
    }

    const AUDIO = {
      coin: new Audio('./app/coin.mp3'),
      // engine: new Audio('./app/engine.mp3'),
      // boost: new Audio('./app/boost.mp3'),
    }
    AUDIO.coin.volume = 0.1
    // AUDIO.engine.loop = true
    // AUDIO.engine.volume = 0.33
    // AUDIO.boost.loop = true
    // AUDIO.boost.volume = 0.2
    // const continue_audio = (audio) => {
    //   if (audio.paused) {
    //     audio.play()
    //   }
    // }

    const update_gui = () => {
      QQ('.gui').map(x => x.style.visibility = 'hidden')
      QQ(`#gui-${state}`).map(x => x.style.visibility = 'visible')

      if (state === STATES.MENU) {
        const l_qr = Q('#matchbox-qr')
        l_qr.innerHTML = ''
        const qr = new QRCode(l_qr, {
          text: location.href.replace('tv.html', 'phone.html'),
          width: 512,
          height: 512,
          colorDark: "#000000",
          colorLight: "#ffffff",
          correctLevel: QRCode.CorrectLevel.H
        })

        const l_select_mode = Q('#matchbox-select-mode')
        l_select_mode.innerHTML = ''
        values(MODES).map(mode => {
          const option = node(`<option value="${mode}">mode: ${mode}</option>`)
          l_select_mode.appendChild(option)
        })
      }

      // if (state === STATES.PLAY) {
      //   document.body.style.cursor = 'none'
      // } else {
      //   document.body.style.cursor = ''
      // }
    }
    update_gui()

    const render = {
      scores: () => {
        const l_scores = Q('#matchbox-scores')
        l_scores.innerHTML = ''
        players.map((player, i) => {
          let l_score
          if (mode === MODES.REGULAR) {
            l_score = node(`<div class="center-row gap">
              <div style="
              background: ${player.color};
              padding: .25em;
              border: 1px solid #fff;
              box-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000;
              min-width: 1em;
              min-height: 1.5em;
              ">
                <div style="font-size: 1.5em; line-height: 1.05" class="row">${'<span>ðŸŸ¡</span>'.repeat(player.score)}</div>
              </div>
              <div style="font-size: 1.5em">${player.score}</div>
            </div>`)
          } else if (mode === MODES.SURVIVAL) {
            l_score = player.out ? node(`<div style="font-size:1.5em">#${players.length - player.out + 1}</div>`) :  node(`<div class="center-row gap">
              <div style="
              background: ${player.color};
              padding: .25em;
              border: 1px solid #fff;
              box-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000;
              min-width: 1em;
              min-height: 1.5em;
              ">
                <div style="font-size: 1.5em; line-height: 1.05" class="row">${'<span>ðŸŸ¡</span>'.repeat(player.score)}</div>
              </div>
              <div style="font-size: 1.5em">${player.score}</div>
            </div>`)
          }
          l_scores.appendChild(l_score)
        })
      },
      final_scores: () => {
        const l_scores = Q('#matchbox-final-scores')
        l_scores.innerHTML = ''
        const max_score = maths.max(players.map(p => p.score))
        players.map((player, i) => {
          // animate crown with slight up and down motion
          let l_score
          if (mode === MODES.REGULAR) {
            l_score = node(`<div class="center-column gap" style="align-items: flex-end">
              <style>
                @keyframes crown {
                  0% { transform: translateY(0); }
                  50% { transform: translateY(-.25em); }
                  100% { transform: translateY(0); }
                }
                .crown {
                  // animation: crown 1s ease-in-out infinite;
                }
              </style>
              ${max_score && player.score === max_score ? '<div class="crown" style="font-size: 1.5em">ðŸ‘‘</div>' : ''}
              <div style="font-size: 1.5em">${player.score}</div>
              <div style="
              background: ${player.color};
              padding: .25em;
              border: 1px solid #fff;
              box-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000;
              min-height: 1em;
              min-width: 1.5em;
              ">
                <div style="
                font-size: 1.5em;
                line-height: 1.05;
                max-height: calc(1.05*15em);
                flex-wrap: wrap;
                flex-direction: column-reverse;
                " class="column">${'<span>ðŸŸ¡</span>'.repeat(player.score)}</div>
              </div>
            </div>`)
          } else if (mode === MODES.SURVIVAL) {
            l_score = node(`<div class="column gap" style="align-items: flex-end">
              ${player.out === players.length ? '<div class="crown" style="font-size: 1.5em">ðŸ‘‘</div>' : ''}
              <div style="
              background: ${player.color};
              padding: .25em;
              border: 1px solid #fff;
              box-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000;
              min-height: 1em;
              min-width: 1.5em;
              ">
                ${players.length - player.out + 1}
              </div>  
            </div>`)
          }
          l_scores.appendChild(l_score)
        })
      },
      timer: () => {
        document.getElementById('timer').innerText = `${Math.floor((Math.min(data.length, data.timer - Date.now())) / 1000)}s`
      },
      countdown: () => {
        // show countdown at start of game - so show time over 60s
        const l_countdown = Q('#matchbox-countdown')
        l_countdown.innerHTML = ''
        const countdown_time = data.timer - duration({ m:1 }) - Date.now()
        const countdown = Math.ceil(countdown_time / 1000)
        if (countdown > 0) {
          l_countdown.innerText = countdown
        } else {
          l_countdown.innerText = ''
        }
      },
    }

    const handle_leave = (data) => {
      const i = players.indexOf(data)
      players.splice(i, 1)
      Q('#matchbox-joined').innerText = players.length

      // if host leaves, assign new host
      if (data.host && players.length) {
        players[0].host = true
        socket.emit('matchbox', { id, player:players[0].player, setting:true, host:true })
      }
    }

    const spawn_car = (vehicle) => {
      // spawn at random location on circle of radius size/5
      const angle = rand.f(Math.PI * 2)
      const radius = size / 5
      const x = Math.cos(angle) * radius
      const y = Math.sin(angle) * radius
      const set_start = () => {
        vehicle.chassisBody.position.set(x * FIELD / size, y * FIELD / size, get_height(x, y) + 4)
        vehicle.chassisBody.velocity.set(0, 0, 0)
        vehicle.chassisBody.angularVelocity.set(0, 0, 0)
        vehicle.chassisBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), angle + Math.PI)
      }
      set_start()
      defer(set_start) // need bc physics engine doesn't update immediately

      const i = player_vehicles.indexOf(vehicle)
      const player = players[i]
      player.spawning = true
    }
    const spawn_coin = (coin) => {
      let x, y, z
      do {
        x = rand.i(FIELD) - FIELD / 2
        y = rand.i(FIELD) - FIELD / 2
        z = get_height(x / tile, y / tile)
      } while (z < liquid_height)
      const set_start = () => {
        coin.position.set(x, y, z + COIN_DIAMETER * 4)
        coin.velocity.set(0, 0, 0)
        coin.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), rand.f(Math.PI * 2))
        coin.angularVelocity.set(0, 0, 0)
      }
      set_start()
      defer(set_start) // need bc physics engine doesn't update immediately
    }

    const N_LIQUID_LAYERS = 5
    let terrain_body, liquid_meshes
    let cleanups = []

    let world, scene, started = false
    const init_game = () => {
      update_gui()
      if (started) {
        clear_game()
      }
      started = true
      
      if (!world) {
        world = runner.world
        world.broadphase = new CANNON.SAPBroadphase(world)
        world.gravity.set(0, 0, -20)
        world.defaultContactMaterial.friction = 1
      }
      
      // spawn terrain - physical and low-poly visual
      let highest_elevation = 0
      randomize_generate()
      // physical
      {
        const tile = 2
        const size_to_tile = (FIELD / tile) / size
        const x_tiles = FIELD/tile, y_tiles = FIELD/tile
        const matrix = []
        for (let i = 0; i < x_tiles; i++) {
          matrix.push([])
          for (let j = 0; j < y_tiles; j++) {
            const height = get_height(i / size_to_tile - size / 2, j / size_to_tile - size / 2)
            highest_elevation = Math.max(highest_elevation, height)
            matrix[i].push(height)
          }
        }
        const hf_shape = new CANNON.Heightfield(matrix, {
          elementSize: tile,
        })
        terrain_body = new CANNON.Body({ mass: 0 })
        terrain_body.addShape(hf_shape)
        terrain_body.position.set(-FIELD/2, -FIELD/2, 0)
        world.add(terrain_body)
        // runner.add_visual(terrain_body, new THREE.MeshLambertMaterial({ color: COLOR_SAND }))
        cleanups.push(() => world.remove(terrain_body))
      }
      // visual
      {
        const x_tiles = size, y_tiles = size
        const matrix = []
        for (let i = 0; i < x_tiles; i++) {
          matrix.push([])
          for (let j = 0; j < y_tiles; j++) {
            const height = get_height(i - size / 2, j - size / 2)
            matrix[i].push(height)
          }
        }
        const terrain_visual_body = new CANNON.Body({ mass: 0 })
        terrain_visual_body.addShape(new CANNON.Heightfield(matrix, {
          elementSize: FIELD / size,
        }))
        const mesh = runner.shape2mesh(terrain_visual_body, new THREE.MeshLambertMaterial({ color: COLOR_SAND }))
        mesh.position.set(-FIELD/2, -FIELD/2, 0)
        mesh.receiveShadow = true
        runner.scene.add(mesh)
        cleanups.push(scene => scene.remove(mesh))
      }

      // spawn bushes - nvm don't, there's a weird rendering issue
      const N_BUSHES = rand.i(16)
      // const loader = new THREE.TextureLoader()
      // const texture = loader.load('./app/bush.png')
      range(N_BUSHES).map(i => {
        // const scale = 10 // rand.i(2, 7)
        // const geometry = new THREE.PlaneBufferGeometry(scale, scale)
        // const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side:T.DoubleSide })
        // const mesh = new THREE.Mesh(geometry, material)
        // let x, y, Z
        // do {
        //   x = rand.i(FIELD) - FIELD / 2
        //   y = rand.i(FIELD) - FIELD / 2
        //   z = get_height(x / tile, y / tile)
        // } while (z < liquid_height)
        // mesh.position.set(x, y, z + scale / 2)
        // mesh.rotation.x = Math.PI / 2
        // mesh.receiveShadow = true
        // mesh.castShadow = true
        // runner.scene.add(mesh)
        // cleanups.push(scene => scene.remove(mesh))

        const height = rand.i(3, 7)
        const bush_shape = new CANNON.Cylinder(1, 1, height, 8)
        const bush_body = new CANNON.Body({ mass:0 })
        const scale = 10 // rand.i(2, 7)
        do {
          x = rand.i(FIELD) - FIELD / 2
          y = rand.i(FIELD) - FIELD / 2
          z = get_height(x / tile, y / tile)
        } while (z < liquid_height)
        bush_body.position.set(x, y, z + height / 2)
        bush_body.addShape(bush_shape)
        world.add(bush_body)
        runner.add_visual(bush_body, new THREE.MeshLambertMaterial({ color: 0x00ff00 }))
      })

      // spawn liquid
      liquid_meshes = range(N_LIQUID_LAYERS).map(i => {
        // add liquid layers to create the illusion of depth. lerp from min_height to liquid_height
        var liquid_geom = new T.CylinderGeometry(size * 10, size * 10, liquid_height, 256)
        liquid_geom.rotateX(Math.PI / 2)
        liquid_geom.translate(0, 0, maths.lerp(min_height - liquid_height*.49, liquid_height/2, i / N_LIQUID_LAYERS / 2 + .5))
        liquid = new T.Mesh(liquid_geom, new T.MeshStandardMaterial({
          metalness: 0,
          flatShading: true,
          color: COLOR_LIQUID,
          transparent: true,
          opacity: i === 0 ? 1 : 0.5,
          side: T.DoubleSide,
        }))
        liquid.receiveShadow = true
        runner.scene.add(liquid)
        cleanups.push(scene => scene.remove(liquid))
        return liquid
      })

      // spawn fog layers
      const N_FOG_LAYERS = 0
      const create_fog_layer = (y) => {
        const fog_geom = new T.PlaneBufferGeometry(size * 10, size * 10)
        fog_geom.translate(0, 0, y)
        const fog = new T.Mesh(fog_geom, new T.MeshStandardMaterial({
          metalness: 0,
          flatShading: true,
          color: 0xffffff,
          transparent: true,
          opacity: 0.1,
          side: T.DoubleSide,
        }))
        runner.scene.add(fog)
        cleanups.push(scene => scene.remove(fog))
        return fog
      }
      const fog_meshes = range(N_FOG_LAYERS).map(i => {
        return create_fog_layer(maths.lerp(liquid_height, max_height / 3, i / N_FOG_LAYERS))
      })
      create_fog_layer(highest_elevation)

      // create all coins and keep off screen until needed
      coins = range(MAX_COINS).map(i => {
        // create gold coin using cannonjs Cylinder
        const coin_shape = new CANNON.Cylinder(COIN_DIAMETER, COIN_DIAMETER, COIN_WIDTH, 8)
        const coin_body = new CANNON.Body({ mass: .01 })
        coin_body.position.set(0, 0, -100)
        coin_body.addShape(coin_shape)
        runner.add_visual(coin_body, new THREE.MeshLambertMaterial({
          metalness: 1,
          color: 0xffd700,
        }))
        world.add(coin_body)
        return coin_body
      })

      // add function to clean up boost particles
      cleanups.push(() => {
        boost_particles.map(list => list.map(x => runner.remove_visual(x)))
        boost_particles = []
      })
      
      let last_t
      {
        const f = () => {
          const t = performance.now()
          if (last_t) {
            const dt = (t - last_t) / 1000
            update(dt)
          }
          last_t = t
        }
        world.addEventListener('postStep', f)
        cleanups.push(() => world.removeEventListener('postStep', f))
      }
    }
    const start_game = () => {
      state = STATES.PLAY

      player_vehicles = []
      player_wheels = []
      players.map((player, i) => {
        let vehicle, wheels

        const body_chassis = new CANNON.Body({ mass:150 })
        body_chassis.addShape(new CANNON.Box(new CANNON.Vec3(1.8, 1, 0.5)))
        body_chassis.addShape(new CANNON.Box(new CANNON.Vec3(.9, 1, .67)), new CANNON.Vec3(-.3, 0, (.5 + .67) / 2))
        body_chassis.position.set(0, 0, 4)
        // body_chassis.angularVelocity.set(0, 0, 0.5)
        const color = parseInt(player.color.slice(1), 16)
        runner.add_visual(body_chassis, new THREE.MeshLambertMaterial({ color }))

        // Create the vehicle
        vehicle = new CANNON.RaycastVehicle({
          chassisBody: body_chassis,
        })
        var options = {
          radius: WHEEL_RADIUS,
          directionLocal: new CANNON.Vec3(0, 0, -1),
          suspensionStiffness: 100,
          suspensionRestLength: 0.1,
          frictionSlip: 5,
          dampingRelaxation: 2.3,
          dampingCompression: 4.4,
          maxSuspensionForce: 10_000,
          rollInfluence: 0.01,
          axleLocal: new CANNON.Vec3(0, 1, 0),
          chassisConnectionPointLocal: new CANNON.Vec3(0, 0, 0),
          maxSuspensionTravel: .1,
          customSlidingRotationalSpeed: -30,
          useCustomSlidingRotationalSpeed: true,
        }
        const o_x = 2
        const o_y = 1.5
        const o_z = -.25
        options.chassisConnectionPointLocal.set(o_x, o_y, o_z)
        vehicle.addWheel({
          ...options,
          isFrontWheel: true
        })
        options.chassisConnectionPointLocal.set(o_x, -o_y, o_z)
        vehicle.addWheel({
          ...options,
          isFrontWheel: true
        })
        options.chassisConnectionPointLocal.set(-o_x, o_y, o_z)
        vehicle.addWheel({
          ...options,
          isFrontWheel: false
        })
        options.chassisConnectionPointLocal.set(-o_x, -o_y, o_z)
        vehicle.addWheel({
          ...options,
          isFrontWheel: false
        })
        vehicle.addToWorld(world)

        var wheelBodies = []
        for (var i = 0; i < vehicle.wheelInfos.length; i++) {
          var wheel = vehicle.wheelInfos[i]
          var cylinderShape = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20)
          var wheelBody = new CANNON.Body({ mass: 1 })
          var q = new CANNON.Quaternion()
          q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)
          wheelBody.addShape(cylinderShape, new CANNON.Vec3(), q)
          wheelBodies.push(wheelBody)
          runner.add_visual(wheelBody, new THREE.MeshLambertMaterial({ color: 0x111111 }))
        }
        wheels = wheelBodies

        // Update wheels
        {
          const f = function () {
            for (var i = 0; i < vehicle.wheelInfos.length; i++) {
              vehicle.updateWheelTransform(i)
              var t = vehicle.wheelInfos[i].worldTransform
              wheelBodies[i].position.copy(t.position)
              wheelBodies[i].quaternion.copy(t.quaternion)
            }
          }
          world.addEventListener('postStep', f)
          cleanups.push(() => world.removeEventListener('postStep', f))
        }

        player_vehicles.push(vehicle)
        player_wheels.push(wheels)
      })

      coins.map(coin => {
        let t_last_score = 0
        coin.addEventListener('collide', (e) => {
          // log('coin collision', e)
          // detect if car or wheel collided with coin and increase score
          
          let hit = false
          players.filter(x => !x.out).map(player => {
            const player_car_bodies = [player_vehicles[players.indexOf(player)].chassisBody].concat(player_wheels[players.indexOf(player)])
            if (player_car_bodies.includes(e.body)) {

              // avoid double counting
              if (Date.now() - t_last_score < 100) return
              t_last_score = Date.now()

              player.score += 1
              AUDIO.coin.play()
              socket.emit('matchbox', { id, player:player.player, coin:true })
              spawn_coin(coin)
              hit = true
            }
          })
          if (hit) {
            render.scores()
          }

          // co-op mode?
          // const targets = player_vehicles.map(v => v.chassisBody).concat(player_wheels.flat())
          // if (targets.includes(e.body)) {
          //   score++
          //   document.getElementById('score').innerText = score
          //   spawn_coin(coin)
          //   t_last_score = Date.now()
          // }
        })
      })

      // spawn coins
      coins.map(coin => spawn_coin(coin))

      // place cars under map until game starts
      player_vehicles.map(vehicle => {
        vehicle.chassisBody.position.set(0, 0, -100)
        vehicle.chassisBody.velocity.set(0, 0, 0)
        vehicle.chassisBody.angularVelocity.set(0, 0, 0)
      })

      // create boost particles
      boost_particles.map(list => list.map(x => runner.remove_visual(x)))
      boost_particles = players.map(() => range(MAX_BOOST_PARTICLES).map(i => {
        // const boost_geom = new T.SphereGeometry(.5, 8, 8)
        // const boost = new T.Mesh(boost_geom, new T.MeshBasicMaterial({
        //   color: 0xbbffff,
        //   transparent: true,
        //   opacity: 0.75,
        // }))
        // runner.scene.add(boost)
        // cleanups.push(scene => scene.remove(boost))

        // // hide off screen
        // boost.position.set(0, 0, -100)

        // return boost

        const boost_body = new CANNON.Body({ mass: 0 })
        const boost_shape = new CANNON.Sphere(.5)
        boost_body.addShape(boost_shape)
        boost_body.position.set(0, 0, -100)
        world.add(boost_body)
        runner.add_visual(boost_body, new THREE.MeshLambertMaterial({ color: 0xbbffff }))
        world.remove(boost_body)
        return boost_body
      }))

      update_gui()
      render.scores()
      const countdown = duration({ s:3 })
      if (mode === MODES.REGULAR) {
        const length = duration({ m:1 })
        data = {
          spawned: false,
          timer: Date.now() + length + countdown,
          length,
        }
      } else if (mode === MODES.SURVIVAL) {
        const length = duration({ m:1 })
        data = {
          spawned: false,
          timer: Date.now() + length + countdown,
          stage: 0,
          length,
        }
      }
    }
    const end_game = () => {
      // hide coins and set final score
      coins.map(coin => coin.position.set(0, 0, -100))
      render.final_scores()
    }
    const clear_game = () => {      
      cleanups.map(cleanup => cleanup(runner.scene))
      cleanups = []
      players.map(player => player.score = 0)
      render.scores()
    }
    const reset_game = () => {
      runner.change('default') // triggers init_game
    }
    const back_to_menu = () => {
      // remove players who left
      players.map(player => {
        if (player.left) {
          handle_leave(player)
        }
      })
      state = STATES.MENU
      reset_game()
      update_gui()
    }

    runner.add('default', init_game)
    runner.start('default')

    var max_steer = Math.PI / 4
    const drive_force = 5_000
    const brake_force = 200
    const friction_force = 5
    const air_rotate_force = 2_000
    const air_rotate_factor = 5
    const air_rotate_wait = 300
    const jump_vel = 15
    document.onkeydown = document.onkeyup = (e) => {
      if (state === STATES.MENU) {
        if (e.key === ' ') {
          start_game()
        }
        return
      }
      var up = (e.type == 'keyup')
      if (!up && e.type !== 'keydown') return

      if (up) {
        keys[e.key] = false
      } else {
        keys[e.key] = true
      }
    }

    const get_vehicle_ground = (vehicle) => {
      let is_grounded = false
      { // raycast from car to ground to check if grounded
        const ray = new CANNON.Ray(
          vehicle.chassisBody.position,
          new CANNON.Vec3(vehicle.chassisBody.position.x, vehicle.chassisBody.position.y, vehicle.chassisBody.position.z - 2)
        )
        const result = new CANNON.RaycastResult()
        ray.intersectBodies([terrain_body], result)
        // console.debug(result)
        if (result.hasHit) {
          is_grounded = true
        }
      }
      let is_controlled = false
      { // raycast from each wheel to ground to check if controlled
        let contact_points = 0
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
          const wheel = vehicle.wheelInfos[i]
          const position = wheel.worldTransform.position
          const ray = new CANNON.Ray(
            position,
            new CANNON.Vec3(position.x, position.y, position.z - 2)
          )
          const result = new CANNON.RaycastResult()
          ray.intersectBodies([terrain_body], result)
          // console.debug(result)
          if (result.hasHit) {
            contact_points++
          }
        }
        is_controlled = contact_points >= 3
      }
      return { is_grounded, is_controlled }
    }

    socket.on('matchbox', (data) => {
      const { id:data_id, player, x, y, boost, brake, jump, join, leave, start } = data
      if (data_id !== id || !player) return
      if (start) {
        if (state === STATES.MENU) start_game()
        if (state === STATES.END) {
          reset_game()
          start_game()
        }
        return
      }
      let i = players.findIndex(p => p.player === player)
      if (!leave) {
        log('join', player)
        if (i < 0) {
          i = players.length
          const claimed_colors = set(players.map(x => x.color))
          const available_colors = COLORS_CAR.filter(x => !claimed_colors.has(x))
          const color = available_colors.length ? rand.sample(available_colors) : rand.sample(COLORS_CAR)
          const host = !players.find(x => x.host)
          players.push({
            player,
            x: 0,
            y: 0,
            boost: false,
            brake: false,
            jump: false,
            score: 0,
            color,
            host,
          })
          Q('#matchbox-joined').innerText = players.length
        }
        const { color, host } = players[i]
        socket.emit('matchbox', { id, player, setting:true, color, host })
      } else if (leave) {
        log('leave', player)
        const data = players.find(x => x.player === player)
        if (data) {
          if (state === STATES.MENU) {
            handle_leave(data)
          } else {
            data.left = true
            Object.assign(data, {
              x: 0,
              y: 0,
              boost: false,
              brake: false,
              jump: false,
            })
          }
        }
        return
      }
      
      if (x !== undefined) players[i].x = x
      if (y !== undefined) players[i].y = y
      if (boost !== undefined) players[i].boost = boost
      if (brake !== undefined) players[i].brake = brake
      if (jump !== undefined) players[i].jump = jump

      if (jump !== undefined) {
        const vehicle = player_vehicles[i]

        const { is_grounded, is_controlled } = get_vehicle_ground(vehicle)

        if (jump !== undefined) {
          if (is_grounded) { // jump if grounded
            vehicle.chassisBody.velocity.z = jump_vel
          }
        }
      }
    })

    const keys = {}
    const update = (dt) => {
      const t = Date.now()
      const sounds = {
        engine: false,
        boost: false,
      }
      data.spawned && players.map((player, i) => {
        // log(pick(player, 'boost brake jump'))
        const vehicle = player_vehicles && player_vehicles[i]
        const { is_grounded, is_controlled } = vehicle && get_vehicle_ground(vehicle)
        if (player.spawning) {
          if (is_grounded) {
            player.spawning = false
          } else {
            return
          }
        }

        if (is_grounded)  {
          player.last_ground = Date.now()
        }
        
        if (vehicle) {

          // interpret x y as steering and throttle, where x and y are in range [-1, 1]
          const local_target_dir = new CANNON.Vec3(player.x, -player.y, 0)
          const local_target_dir_world = vehicle.chassisBody.quaternion.vmult(local_target_dir)
          const x = local_target_dir_world.x
          const y = local_target_dir_world.y

          const target_angle = (y || x) ? Math.atan2(y, -x) : 0
          const steer_angle = Math.max(-max_steer, Math.min(target_angle, max_steer))
          // log(...[target_angle, steer_angle].map(x => (x * 180 / Math.PI).toFixed(2)))

          // throttle is magnitude of x, y in direction of car - from 1 if forward to 0 if backward
          const throttle = Math.sqrt(x*x + y*y) // * (((maths.TAU - target_angle) / maths.TAU) / 2 + 0.5)
          if (throttle) {
            sounds.engine = true
          }
          let throttle_force = drive_force * throttle
          // if speed is greater than max_speed, throttle is 0
          if (vehicle.chassisBody.velocity.length() > 30) {
            log('max speed')
            throttle_force = 0
          }
          
          // if moving, apply friction
          let applied_friction_force = friction_force
          if (vehicle.chassisBody.velocity.length() < 5) {
            applied_friction_force = 0
          }
          vehicle.setBrake(applied_friction_force, 0)
          vehicle.setBrake(applied_friction_force, 1)
          vehicle.setBrake(applied_friction_force, 2)
          vehicle.setBrake(applied_friction_force, 3)
          vehicle.applyEngineForce(0, 0)
          vehicle.applyEngineForce(0, 1)
          vehicle.applyEngineForce(0, 2)
          vehicle.applyEngineForce(0, 3)
          vehicle.setSteeringValue(0, 0)
          vehicle.setSteeringValue(0, 1)
          if (player.brake || !throttle) {
            vehicle.setBrake(brake_force, 2)
            vehicle.setBrake(brake_force, 3)
          } else if (is_controlled && throttle) {
            vehicle.applyEngineForce(-throttle_force, 0)
            vehicle.applyEngineForce(-throttle_force, 1)
            vehicle.setSteeringValue(steer_angle, 0)
            vehicle.setSteeringValue(steer_angle, 1)
            // downforce
            vehicle.chassisBody.applyLocalForce(new CANNON.Vec3(0, 0, -drive_force/5), new CANNON.Vec3(0, 0, 0))
          } else {
            // air roll
            // apply rotational force at x,y position around car
            if (player.last_ground && Date.now() - player.last_ground > air_rotate_wait) {
              if (throttle) {
                // vehicle.chassisBody.angularVelocity.set(player.y * air_rotate_factor, -player.x * air_rotate_factor, 0)
                const p = vehicle.chassisBody.position
                vehicle.chassisBody.applyForce(new CANNON.Vec3(0, 0, -air_rotate_force), new CANNON.Vec3(p.x - player.x, p.y - player.y, 0))
              }
            } else {
              // try to stabilize car back to no rotation without hacking physics - use applyForce or applyLocalForce, not angulerVelocity.set
              // TODO (maybe)
            }
          }

          if (player.boost) {
            sounds.boost = true
            vehicle.chassisBody.applyLocalForce(new CANNON.Vec3(drive_force, 0, 0), new CANNON.Vec3(0, 0, 0))
            // downforce
            // vehicle.chassisBody.applyLocalForce(new CANNON.Vec3(0, 0, -drive_force/3), new CANNON.Vec3(0, 0, 0))

            const boost = boost_particles[i].shift()
            boost_particles[i].push(boost)
            // move next boost particle to car
            boost.position.copy(vehicle.chassisBody.position)
            boost.position.z -= .5
            boost.position.x += rand.s(.5)
            boost.position.y += rand.s(.5)
            const t = boost.t = Date.now()
            setTimeout(() => {
              if (boost.t === t) {
                boost.position.set(0, 0, -100)
              }
            }, 1000)
          }

          // if car is below liquid_height, respawn at start
          if (vehicle.chassisBody.position.z + 1 < liquid_height) {
            spawn_car(vehicle)
            // halve score
            if (state === STATES.PLAY) {
              player.score = Math.floor(player.score / 2)
              render.scores()
            }
          }

          // if wheel is below get_height, move to get_height
          // player_wheels[i].map(wheel => {
          //   if (wheel.position.z < get_height(wheel.position.x / tile, wheel.position.y / tile) - WHEEL_RADIUS) {
          //     wheel.position.z = get_height(wheel.position.x / tile, wheel.position.y / tile) + WHEEL_RADIUS
          //   }
          // })
        }
      })
      
      // play sounds
      // if (sounds.boost) continue_audio(AUDIO.boost)
      // else AUDIO.boost.pause()
      // if (sounds.engine) continue_audio(AUDIO.engine)
      // else AUDIO.engine.pause()

      if (state === STATES.PLAY) {
        let did_end_game = false
        if (mode === MODES.REGULAR) {
          if (t > data.timer) {
            state = STATES.END
            end_game()
            update_gui()
            did_end_game = true

            // next circuit game
            const scores = Object.fromEntries(players.map(player => [player.player, player.score]))
            circuit.gameover(scores)
            circuit.execute()
            circuit.navigate(socket)
          }
        } else if (mode === MODES.SURVIVAL) {
          if (t > data.timer) {
            data.stage += 1
            data.timer = t + duration({ s:30 })

            // remove player with fewest coins
            const min_score = maths.min(players.map(x => x.score))
            const min_player = rand.shuffle(players).find(x => x.score === min_score)
            // the player will not longer be able to pick up coins
            min_player.out = data.stage

            // set all player coins to 0
            players.map(p => p.score = 0)

            render.scores()

            // end game if only one player left
            const players_left = players.filter(x => !x.out)
            if (players_left.length === 1) {
              players_left[0].out = data.stage + 1
              state = STATES.END
              end_game()
              update_gui()
              did_end_game = true
            }
          }
        }
        
        if (!did_end_game) {
          // spawn cars if time is under 60s and not spawned yet
          if (data.timer - Date.now() - duration({ s:60 }) < 0 && !data.spawned) {
            data.spawned = true
            player_vehicles.map(vehicle => spawn_car(vehicle))
          }

          // if a coin is below liquid_height, respawn at random location
          coins.map(coin => {
            if (coin.position.z - COIN_DIAMETER/2 < liquid_height) {
              spawn_coin(coin)
            }
          })
  
          // set all coins upright
          coins.map(coin => {
            coin.angularVelocity.set(0, 0, 0)
            coin.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)
            // coin.velocity.x = 0
            // coin.velocity.y = 0
          })
  
          // match timer
          render.timer()

          // countdown at start of game
          render.countdown()
        }
      }

      // move liquids like waves (except first layer)
      liquid_meshes.map((liquid, i) => {
        if (i < N_LIQUID_LAYERS - 1) return
        // liquid.position.z = maths.lerp(min_height - liquid_height*.49, liquid_height/2, i / N_LIQUID_LAYERS / 2 + .5) + Math.sin(t / 1000 * 2 + i) * 4
      })
    }

    const on_connect = () => {
      socket.emit('join', `matchbox-${id}`)
      socket.emit('matchbox', { id, ready:true })
    }
    socket.on('connect', on_connect)
    on_connect()

  </script>
</body>

</html>